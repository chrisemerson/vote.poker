
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
(function () {
	'use strict';

	// generated during release, do not modify
	const PUBLIC_VERSION = '5';

	if (typeof window !== 'undefined') {
		// @ts-expect-error
		((window.__svelte ??= {}).v ??= new Set()).add(PUBLIC_VERSION);
	}

	let async_mode_flag = false;
	let legacy_mode_flag = false;
	let tracing_mode_flag = false;

	function enable_legacy_mode_flag() {
		legacy_mode_flag = true;
	}

	enable_legacy_mode_flag();

	const EACH_ITEM_REACTIVE = 1;
	const EACH_INDEX_REACTIVE = 1 << 1;
	/** See EachBlock interface metadata.is_controlled for an explanation what this is */
	const EACH_IS_CONTROLLED = 1 << 2;
	const EACH_IS_ANIMATED = 1 << 3;
	const EACH_ITEM_IMMUTABLE = 1 << 4;

	const PROPS_IS_IMMUTABLE = 1;
	const PROPS_IS_RUNES = 1 << 1;
	const PROPS_IS_UPDATED = 1 << 2;
	const PROPS_IS_BINDABLE = 1 << 3;
	const PROPS_IS_LAZY_INITIAL = 1 << 4;

	const TEMPLATE_FRAGMENT = 1;
	const TEMPLATE_USE_IMPORT_NODE = 1 << 1;

	const UNINITIALIZED = Symbol();

	// Dev-time component properties
	const FILENAME = Symbol('filename');

	const node_env = globalThis.process?.env?.NODE_ENV;
	var DEV = node_env && !node_env.toLowerCase().startsWith('prod');

	// Store the references to globals in case someone tries to monkey patch these, causing the below
	// to de-opt (this occurs often when using popular extensions).
	var is_array = Array.isArray;
	var index_of = Array.prototype.indexOf;
	var array_from = Array.from;
	var define_property = Object.defineProperty;
	var get_descriptor = Object.getOwnPropertyDescriptor;
	var get_descriptors = Object.getOwnPropertyDescriptors;
	var object_prototype = Object.prototype;
	var array_prototype = Array.prototype;
	var get_prototype_of = Object.getPrototypeOf;

	const noop = () => {};

	/** @param {Function} fn */
	function run(fn) {
		return fn();
	}

	/** @param {Array<() => void>} arr */
	function run_all(arr) {
		for (var i = 0; i < arr.length; i++) {
			arr[i]();
		}
	}

	/**
	 * TODO replace with Promise.withResolvers once supported widely enough
	 * @template T
	 */
	function deferred() {
		/** @type {(value: T) => void} */
		var resolve;

		/** @type {(reason: any) => void} */
		var reject;

		/** @type {Promise<T>} */
		var promise = new Promise((res, rej) => {
			resolve = res;
			reject = rej;
		});

		// @ts-expect-error
		return { promise, resolve, reject };
	}

	const DERIVED = 1 << 1;
	const EFFECT = 1 << 2;
	const RENDER_EFFECT = 1 << 3;
	const BLOCK_EFFECT = 1 << 4;
	const BRANCH_EFFECT = 1 << 5;
	const ROOT_EFFECT = 1 << 6;
	const BOUNDARY_EFFECT = 1 << 7;
	const UNOWNED = 1 << 8;
	const DISCONNECTED = 1 << 9;
	const CLEAN = 1 << 10;
	const DIRTY = 1 << 11;
	const MAYBE_DIRTY = 1 << 12;
	const INERT = 1 << 13;
	const DESTROYED = 1 << 14;
	const EFFECT_RAN = 1 << 15;
	/** 'Transparent' effects do not create a transition boundary */
	const EFFECT_TRANSPARENT = 1 << 16;
	const INSPECT_EFFECT = 1 << 17;
	const HEAD_EFFECT = 1 << 18;
	const EFFECT_PRESERVED = 1 << 19;
	const USER_EFFECT = 1 << 20;

	// Flags used for async
	const REACTION_IS_UPDATING = 1 << 21;
	const ASYNC = 1 << 22;

	const ERROR_VALUE = 1 << 23;

	const STATE_SYMBOL = Symbol('$state');
	const LEGACY_PROPS = Symbol('legacy props');
	const PROXY_PATH_SYMBOL = Symbol('proxy path');

	/** allow users to ignore aborted signal errors if `reason.name === 'StaleReactionError` */
	const STALE_REACTION = new (class StaleReactionError extends Error {
		name = 'StaleReactionError';
		message = 'The reaction that called `getAbortSignal()` was re-run or destroyed';
	})();

	const ELEMENT_NODE = 1;
	const DOCUMENT_FRAGMENT_NODE = 11;

	/* This file is generated by scripts/process-messages/index.js. Do not edit! */

	/**
	 * `%name%` is not a store with a `subscribe` method
	 * @param {string} name
	 * @returns {never}
	 */
	function store_invalid_shape(name) {
		if (DEV) {
			const error = new Error(`store_invalid_shape\n\`${name}\` is not a store with a \`subscribe\` method\nhttps://svelte.dev/e/store_invalid_shape`);

			error.name = 'Svelte error';

			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/store_invalid_shape`);
		}
	}

	/* This file is generated by scripts/process-messages/index.js. Do not edit! */

	/**
	 * Cannot create a `$derived(...)` with an `await` expression outside of an effect tree
	 * @returns {never}
	 */
	function async_derived_orphan() {
		if (DEV) {
			const error = new Error(`async_derived_orphan\nCannot create a \`$derived(...)\` with an \`await\` expression outside of an effect tree\nhttps://svelte.dev/e/async_derived_orphan`);

			error.name = 'Svelte error';

			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/async_derived_orphan`);
		}
	}

	/**
	 * Using `bind:value` together with a checkbox input is not allowed. Use `bind:checked` instead
	 * @returns {never}
	 */
	function bind_invalid_checkbox_value() {
		if (DEV) {
			const error = new Error(`bind_invalid_checkbox_value\nUsing \`bind:value\` together with a checkbox input is not allowed. Use \`bind:checked\` instead\nhttps://svelte.dev/e/bind_invalid_checkbox_value`);

			error.name = 'Svelte error';

			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/bind_invalid_checkbox_value`);
		}
	}

	/**
	 * Calling `%method%` on a component instance (of %component%) is no longer valid in Svelte 5
	 * @param {string} method
	 * @param {string} component
	 * @returns {never}
	 */
	function component_api_changed(method, component) {
		if (DEV) {
			const error = new Error(`component_api_changed\nCalling \`${method}\` on a component instance (of ${component}) is no longer valid in Svelte 5\nhttps://svelte.dev/e/component_api_changed`);

			error.name = 'Svelte error';

			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/component_api_changed`);
		}
	}

	/**
	 * Attempted to instantiate %component% with `new %name%`, which is no longer valid in Svelte 5. If this component is not under your control, set the `compatibility.componentApi` compiler option to `4` to keep it working.
	 * @param {string} component
	 * @param {string} name
	 * @returns {never}
	 */
	function component_api_invalid_new(component, name) {
		if (DEV) {
			const error = new Error(`component_api_invalid_new\nAttempted to instantiate ${component} with \`new ${name}\`, which is no longer valid in Svelte 5. If this component is not under your control, set the \`compatibility.componentApi\` compiler option to \`4\` to keep it working.\nhttps://svelte.dev/e/component_api_invalid_new`);

			error.name = 'Svelte error';

			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/component_api_invalid_new`);
		}
	}

	/**
	 * A derived value cannot reference itself recursively
	 * @returns {never}
	 */
	function derived_references_self() {
		if (DEV) {
			const error = new Error(`derived_references_self\nA derived value cannot reference itself recursively\nhttps://svelte.dev/e/derived_references_self`);

			error.name = 'Svelte error';

			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/derived_references_self`);
		}
	}

	/**
	 * `%rune%` cannot be used inside an effect cleanup function
	 * @param {string} rune
	 * @returns {never}
	 */
	function effect_in_teardown(rune) {
		if (DEV) {
			const error = new Error(`effect_in_teardown\n\`${rune}\` cannot be used inside an effect cleanup function\nhttps://svelte.dev/e/effect_in_teardown`);

			error.name = 'Svelte error';

			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/effect_in_teardown`);
		}
	}

	/**
	 * Effect cannot be created inside a `$derived` value that was not itself created inside an effect
	 * @returns {never}
	 */
	function effect_in_unowned_derived() {
		if (DEV) {
			const error = new Error(`effect_in_unowned_derived\nEffect cannot be created inside a \`$derived\` value that was not itself created inside an effect\nhttps://svelte.dev/e/effect_in_unowned_derived`);

			error.name = 'Svelte error';

			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/effect_in_unowned_derived`);
		}
	}

	/**
	 * `%rune%` can only be used inside an effect (e.g. during component initialisation)
	 * @param {string} rune
	 * @returns {never}
	 */
	function effect_orphan(rune) {
		if (DEV) {
			const error = new Error(`effect_orphan\n\`${rune}\` can only be used inside an effect (e.g. during component initialisation)\nhttps://svelte.dev/e/effect_orphan`);

			error.name = 'Svelte error';

			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/effect_orphan`);
		}
	}

	/**
	 * Maximum update depth exceeded. This typically indicates that an effect reads and writes the same piece of state
	 * @returns {never}
	 */
	function effect_update_depth_exceeded() {
		if (DEV) {
			const error = new Error(`effect_update_depth_exceeded\nMaximum update depth exceeded. This typically indicates that an effect reads and writes the same piece of state\nhttps://svelte.dev/e/effect_update_depth_exceeded`);

			error.name = 'Svelte error';

			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/effect_update_depth_exceeded`);
		}
	}

	/**
	 * Cannot do `bind:%key%={undefined}` when `%key%` has a fallback value
	 * @param {string} key
	 * @returns {never}
	 */
	function props_invalid_value(key) {
		if (DEV) {
			const error = new Error(`props_invalid_value\nCannot do \`bind:${key}={undefined}\` when \`${key}\` has a fallback value\nhttps://svelte.dev/e/props_invalid_value`);

			error.name = 'Svelte error';

			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/props_invalid_value`);
		}
	}

	/**
	 * The `%rune%` rune is only available inside `.svelte` and `.svelte.js/ts` files
	 * @param {string} rune
	 * @returns {never}
	 */
	function rune_outside_svelte(rune) {
		if (DEV) {
			const error = new Error(`rune_outside_svelte\nThe \`${rune}\` rune is only available inside \`.svelte\` and \`.svelte.js/ts\` files\nhttps://svelte.dev/e/rune_outside_svelte`);

			error.name = 'Svelte error';

			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/rune_outside_svelte`);
		}
	}

	/**
	 * Property descriptors defined on `$state` objects must contain `value` and always be `enumerable`, `configurable` and `writable`.
	 * @returns {never}
	 */
	function state_descriptors_fixed() {
		if (DEV) {
			const error = new Error(`state_descriptors_fixed\nProperty descriptors defined on \`$state\` objects must contain \`value\` and always be \`enumerable\`, \`configurable\` and \`writable\`.\nhttps://svelte.dev/e/state_descriptors_fixed`);

			error.name = 'Svelte error';

			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/state_descriptors_fixed`);
		}
	}

	/**
	 * Cannot set prototype of `$state` object
	 * @returns {never}
	 */
	function state_prototype_fixed() {
		if (DEV) {
			const error = new Error(`state_prototype_fixed\nCannot set prototype of \`$state\` object\nhttps://svelte.dev/e/state_prototype_fixed`);

			error.name = 'Svelte error';

			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/state_prototype_fixed`);
		}
	}

	/**
	 * Updating state inside `$derived(...)`, `$inspect(...)` or a template expression is forbidden. If the value should not be reactive, declare it without `$state`
	 * @returns {never}
	 */
	function state_unsafe_mutation() {
		if (DEV) {
			const error = new Error(`state_unsafe_mutation\nUpdating state inside \`$derived(...)\`, \`$inspect(...)\` or a template expression is forbidden. If the value should not be reactive, declare it without \`$state\`\nhttps://svelte.dev/e/state_unsafe_mutation`);

			error.name = 'Svelte error';

			throw error;
		} else {
			throw new Error(`https://svelte.dev/e/state_unsafe_mutation`);
		}
	}

	/* This file is generated by scripts/process-messages/index.js. Do not edit! */

	var bold = 'font-weight: bold';
	var normal = 'font-weight: normal';

	/**
	 * Detected reactivity loss when reading `%name%`. This happens when state is read in an async function after an earlier `await`
	 * @param {string} name
	 */
	function await_reactivity_loss(name) {
		if (DEV) {
			console.warn(`%c[svelte] await_reactivity_loss\n%cDetected reactivity loss when reading \`${name}\`. This happens when state is read in an async function after an earlier \`await\`\nhttps://svelte.dev/e/await_reactivity_loss`, bold, normal);
		} else {
			console.warn(`https://svelte.dev/e/await_reactivity_loss`);
		}
	}

	/**
	 * An async derived, `%name%` (%location%) was not read immediately after it resolved. This often indicates an unnecessary waterfall, which can slow down your app
	 * @param {string} name
	 * @param {string} location
	 */
	function await_waterfall(name, location) {
		if (DEV) {
			console.warn(`%c[svelte] await_waterfall\n%cAn async derived, \`${name}\` (${location}) was not read immediately after it resolved. This often indicates an unnecessary waterfall, which can slow down your app\nhttps://svelte.dev/e/await_waterfall`, bold, normal);
		} else {
			console.warn(`https://svelte.dev/e/await_waterfall`);
		}
	}

	/**
	 * %handler% should be a function. Did you mean to %suggestion%?
	 * @param {string} handler
	 * @param {string} suggestion
	 */
	function event_handler_invalid(handler, suggestion) {
		if (DEV) {
			console.warn(`%c[svelte] event_handler_invalid\n%c${handler} should be a function. Did you mean to ${suggestion}?\nhttps://svelte.dev/e/event_handler_invalid`, bold, normal);
		} else {
			console.warn(`https://svelte.dev/e/event_handler_invalid`);
		}
	}

	/**
	 * Reactive `$state(...)` proxies and the values they proxy have different identities. Because of this, comparisons with `%operator%` will produce unexpected results
	 * @param {string} operator
	 */
	function state_proxy_equality_mismatch(operator) {
		if (DEV) {
			console.warn(`%c[svelte] state_proxy_equality_mismatch\n%cReactive \`$state(...)\` proxies and the values they proxy have different identities. Because of this, comparisons with \`${operator}\` will produce unexpected results\nhttps://svelte.dev/e/state_proxy_equality_mismatch`, bold, normal);
		} else {
			console.warn(`https://svelte.dev/e/state_proxy_equality_mismatch`);
		}
	}

	/** @import { TemplateNode } from '#client' */

	/**
	 * Use this variable to guard everything related to hydration code so it can be treeshaken out
	 * if the user doesn't use the `hydrate` method and these code paths are therefore not needed.
	 */
	let hydrating = false;

	/** @import { Equals } from '#client' */

	/** @type {Equals} */
	function equals(value) {
		return value === this.v;
	}

	/**
	 * @param {unknown} a
	 * @param {unknown} b
	 * @returns {boolean}
	 */
	function safe_not_equal(a, b) {
		return a != a
			? b == b
			: a !== b || (a !== null && typeof a === 'object') || typeof a === 'function';
	}

	/** @type {Equals} */
	function safe_equals(value) {
		return !safe_not_equal(value, this.v);
	}

	/** @import { Derived, Reaction, Value } from '#client' */

	/**
	 * @param {string} label
	 * @returns {Error & { stack: string } | null}
	 */
	function get_stack(label) {
		let error = Error();
		const stack = error.stack;

		if (!stack) return null;

		const lines = stack.split('\n');
		const new_lines = ['\n'];

		for (let i = 0; i < lines.length; i++) {
			const line = lines[i];

			if (line === 'Error') {
				continue;
			}
			if (line.includes('validate_each_keys')) {
				return null;
			}
			if (line.includes('svelte/src/internal')) {
				continue;
			}
			new_lines.push(line);
		}

		if (new_lines.length === 1) {
			return null;
		}

		define_property(error, 'stack', {
			value: new_lines.join('\n')
		});

		define_property(error, 'name', {
			// 'Error' suffix is required for stack traces to be rendered properly
			value: `${label}Error`
		});

		return /** @type {Error & { stack: string }} */ (error);
	}

	/**
	 * @param {Value} source
	 * @param {string} label
	 */
	function tag(source, label) {
		source.label = label;
		tag_proxy(source.v, label);

		return source;
	}

	/**
	 * @param {unknown} value
	 * @param {string} label
	 */
	function tag_proxy(value, label) {
		// @ts-expect-error
		value?.[PROXY_PATH_SYMBOL]?.(label);
		return value;
	}

	/** @import { ComponentContext, DevStackEntry, Effect } from '#client' */

	/** @type {ComponentContext | null} */
	let component_context = null;

	/** @param {ComponentContext | null} context */
	function set_component_context(context) {
		component_context = context;
	}

	/** @type {DevStackEntry | null} */
	let dev_stack = null;

	/** @param {DevStackEntry | null} stack */
	function set_dev_stack(stack) {
		dev_stack = stack;
	}

	/**
	 * Execute a callback with a new dev stack entry
	 * @param {() => any} callback - Function to execute
	 * @param {DevStackEntry['type']} type - Type of block/component
	 * @param {any} component - Component function
	 * @param {number} line - Line number
	 * @param {number} column - Column number
	 * @param {Record<string, any>} [additional] - Any additional properties to add to the dev stack entry
	 * @returns {any}
	 */
	function add_svelte_meta(callback, type, component, line, column, additional) {
		const parent = dev_stack;

		dev_stack = {
			type,
			file: component[FILENAME],
			line,
			column,
			parent,
			...additional
		};

		try {
			return callback();
		} finally {
			dev_stack = parent;
		}
	}

	/**
	 * The current component function. Different from current component context:
	 * ```html
	 * <!-- App.svelte -->
	 * <Foo>
	 *   <Bar /> <!-- context == Foo.svelte, function == App.svelte -->
	 * </Foo>
	 * ```
	 * @type {ComponentContext['function']}
	 */
	let dev_current_component_function = null;

	/** @param {ComponentContext['function']} fn */
	function set_dev_current_component_function(fn) {
		dev_current_component_function = fn;
	}

	/**
	 * @param {Record<string, unknown>} props
	 * @param {any} runes
	 * @param {Function} [fn]
	 * @returns {void}
	 */
	function push(props, runes = false, fn) {
		component_context = {
			p: component_context,
			c: null,
			e: null,
			s: props,
			x: null,
			l: legacy_mode_flag && !runes ? { s: null, u: null, $: [] } : null
		};

		if (DEV) {
			// component function
			component_context.function = fn;
			dev_current_component_function = fn;
		}
	}

	/**
	 * @template {Record<string, any>} T
	 * @param {T} [component]
	 * @returns {T}
	 */
	function pop(component) {
		var context = /** @type {ComponentContext} */ (component_context);
		var effects = context.e;

		if (effects !== null) {
			context.e = null;

			for (var fn of effects) {
				create_user_effect(fn);
			}
		}

		if (component !== undefined) {
			context.x = component;
		}

		component_context = context.p;

		if (DEV) {
			dev_current_component_function = component_context?.function ?? null;
		}

		return component ?? /** @type {T} */ ({});
	}

	/** @returns {boolean} */
	function is_runes() {
		return !legacy_mode_flag || (component_context !== null && component_context.l === null);
	}

	/** @type {Array<() => void>} */
	let micro_tasks = [];

	function run_micro_tasks() {
		var tasks = micro_tasks;
		micro_tasks = [];
		run_all(tasks);
	}

	/**
	 * @param {() => void} fn
	 */
	function queue_micro_task(fn) {
		if (micro_tasks.length === 0 && !is_flushing_sync) {
			var tasks = micro_tasks;
			queueMicrotask(() => {
				// If this is false, a flushSync happened in the meantime. Do _not_ run new scheduled microtasks in that case
				// as the ordering of microtasks would be broken at that point - consider this case:
				// - queue_micro_task schedules microtask A to flush task X
				// - synchronously after, flushSync runs, processing task X
				// - synchronously after, some other microtask B is scheduled, but not through queue_micro_task but for example a Promise.resolve() in user code
				// - synchronously after, queue_micro_task schedules microtask C to flush task Y
				// - one tick later, microtask A now resolves, flushing task Y before microtask B, which is incorrect
				// This if check prevents that race condition (that realistically will only happen in tests)
				if (tasks === micro_tasks) run_micro_tasks();
			});
		}

		micro_tasks.push(fn);
	}

	/**
	 * Synchronously run any queued tasks.
	 */
	function flush_tasks() {
		while (micro_tasks.length > 0) {
			run_micro_tasks();
		}
	}

	/** @import { Derived, Effect } from '#client' */

	const adjustments = new WeakMap();

	/**
	 * @param {unknown} error
	 */
	function handle_error(error) {
		var effect = active_effect;

		// for unowned deriveds, don't throw until we read the value
		if (effect === null) {
			/** @type {Derived} */ (active_reaction).f |= ERROR_VALUE;
			return error;
		}

		if (DEV && error instanceof Error && !adjustments.has(error)) {
			adjustments.set(error, get_adjustments(error, effect));
		}

		if ((effect.f & EFFECT_RAN) === 0) {
			// if the error occurred while creating this subtree, we let it
			// bubble up until it hits a boundary that can handle it
			if ((effect.f & BOUNDARY_EFFECT) === 0) {
				if (!effect.parent && error instanceof Error) {
					apply_adjustments(error);
				}

				throw error;
			}

			/** @type {Boundary} */ (effect.b).error(error);
		} else {
			// otherwise we bubble up the effect tree ourselves
			invoke_error_boundary(error, effect);
		}
	}

	/**
	 * @param {unknown} error
	 * @param {Effect | null} effect
	 */
	function invoke_error_boundary(error, effect) {
		while (effect !== null) {
			if ((effect.f & BOUNDARY_EFFECT) !== 0) {
				try {
					/** @type {Boundary} */ (effect.b).error(error);
					return;
				} catch (e) {
					error = e;
				}
			}

			effect = effect.parent;
		}

		if (error instanceof Error) {
			apply_adjustments(error);
		}

		throw error;
	}

	/**
	 * Add useful information to the error message/stack in development
	 * @param {Error} error
	 * @param {Effect} effect
	 */
	function get_adjustments(error, effect) {
		const message_descriptor = get_descriptor(error, 'message');

		// if the message was already changed and it's not configurable we can't change it
		// or it will throw a different error swallowing the original error
		if (message_descriptor && !message_descriptor.configurable) return;

		var indent = '\t';
		var component_stack = `\n${indent}in ${effect.fn?.name || '<unknown>'}`;
		var context = effect.ctx;

		while (context !== null) {
			component_stack += `\n${indent}in ${context.function?.[FILENAME].split('/').pop()}`;
			context = context.p;
		}

		return {
			message: error.message + `\n${component_stack}\n`,
			stack: error.stack
				?.split('\n')
				.filter((line) => !line.includes('svelte/src/internal'))
				.join('\n')
		};
	}

	/**
	 * @param {Error} error
	 */
	function apply_adjustments(error) {
		const adjusted = adjustments.get(error);

		if (adjusted) {
			define_property(error, 'message', {
				value: adjusted.message
			});

			define_property(error, 'stack', {
				value: adjusted.stack
			});
		}
	}

	/** @import { Derived, Effect, Source, Value } from '#client' */

	/** @type {Set<Batch>} */
	const batches = new Set();

	/** @type {Batch | null} */
	let current_batch = null;

	/**
	 * This is needed to avoid overwriting inputs in non-async mode
	 * TODO 6.0 remove this, as non-async mode will go away
	 * @type {Batch | null}
	 */
	let previous_batch = null;

	/**
	 * When time travelling, we re-evaluate deriveds based on the temporary
	 * values of their dependencies rather than their actual values, and cache
	 * the results in this map rather than on the deriveds themselves
	 * @type {Map<Derived, any> | null}
	 */
	let batch_deriveds = null;

	/** @type {Set<() => void>} */
	let effect_pending_updates = new Set();

	/** @type {Effect[]} */
	let queued_root_effects = [];

	/** @type {Effect | null} */
	let last_scheduled_effect = null;

	let is_flushing = false;
	let is_flushing_sync = false;

	class Batch {
		/**
		 * The current values of any sources that are updated in this batch
		 * They keys of this map are identical to `this.#previous`
		 * @type {Map<Source, any>}
		 */
		current = new Map();

		/**
		 * The values of any sources that are updated in this batch _before_ those updates took place.
		 * They keys of this map are identical to `this.#current`
		 * @type {Map<Source, any>}
		 */
		#previous = new Map();

		/**
		 * When the batch is committed (and the DOM is updated), we need to remove old branches
		 * and append new ones by calling the functions added inside (if/each/key/etc) blocks
		 * @type {Set<() => void>}
		 */
		#callbacks = new Set();

		/**
		 * The number of async effects that are currently in flight
		 */
		#pending = 0;

		/**
		 * A deferred that resolves when the batch is committed, used with `settled()`
		 * TODO replace with Promise.withResolvers once supported widely enough
		 * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
		 */
		#deferred = null;

		/**
		 * Async effects inside a newly-created `<svelte:boundary>`
		 * — these do not prevent the batch from committing
		 * @type {Effect[]}
		 */
		#boundary_async_effects = [];

		/**
		 * Template effects and `$effect.pre` effects, which run when
		 * a batch is committed
		 * @type {Effect[]}
		 */
		#render_effects = [];

		/**
		 * The same as `#render_effects`, but for `$effect` (which runs after)
		 * @type {Effect[]}
		 */
		#effects = [];

		/**
		 * Block effects, which may need to re-run on subsequent flushes
		 * in order to update internal sources (e.g. each block items)
		 * @type {Effect[]}
		 */
		#block_effects = [];

		/**
		 * Deferred effects (which run after async work has completed) that are DIRTY
		 * @type {Effect[]}
		 */
		#dirty_effects = [];

		/**
		 * Deferred effects that are MAYBE_DIRTY
		 * @type {Effect[]}
		 */
		#maybe_dirty_effects = [];

		/**
		 * A set of branches that still exist, but will be destroyed when this batch
		 * is committed — we skip over these during `process`
		 * @type {Set<Effect>}
		 */
		skipped_effects = new Set();

		/**
		 *
		 * @param {Effect[]} root_effects
		 */
		process(root_effects) {
			queued_root_effects = [];

			previous_batch = null;

			var revert = Batch.apply(this);

			for (const root of root_effects) {
				this.#traverse_effect_tree(root);
			}

			// if we didn't start any new async work, and no async work
			// is outstanding from a previous flush, commit
			if (this.#pending === 0) {
				this.#commit();

				var render_effects = this.#render_effects;
				var effects = this.#effects;

				this.#render_effects = [];
				this.#effects = [];
				this.#block_effects = [];

				// If sources are written to, then work needs to happen in a separate batch, else prior sources would be mixed with
				// newly updated sources, which could lead to infinite loops when effects run over and over again.
				previous_batch = this;
				current_batch = null;

				flush_queued_effects(render_effects);
				flush_queued_effects(effects);

				this.#deferred?.resolve();
			} else {
				this.#defer_effects(this.#render_effects);
				this.#defer_effects(this.#effects);
				this.#defer_effects(this.#block_effects);
			}

			revert();

			for (const effect of this.#boundary_async_effects) {
				update_effect(effect);
			}

			this.#boundary_async_effects = [];
		}

		/**
		 * Traverse the effect tree, executing effects or stashing
		 * them for later execution as appropriate
		 * @param {Effect} root
		 */
		#traverse_effect_tree(root) {
			root.f ^= CLEAN;

			var effect = root.first;

			while (effect !== null) {
				var flags = effect.f;
				var is_branch = (flags & (BRANCH_EFFECT | ROOT_EFFECT)) !== 0;
				var is_skippable_branch = is_branch && (flags & CLEAN) !== 0;

				var skip = is_skippable_branch || (flags & INERT) !== 0 || this.skipped_effects.has(effect);

				if (!skip && effect.fn !== null) {
					if (is_branch) {
						effect.f ^= CLEAN;
					} else if ((flags & EFFECT) !== 0) {
						this.#effects.push(effect);
					} else if ((flags & CLEAN) === 0) {
						if ((flags & ASYNC) !== 0 && effect.b?.is_pending()) {
							this.#boundary_async_effects.push(effect);
						} else if (is_dirty(effect)) {
							if ((effect.f & BLOCK_EFFECT) !== 0) this.#block_effects.push(effect);
							update_effect(effect);
						}
					}

					var child = effect.first;

					if (child !== null) {
						effect = child;
						continue;
					}
				}

				var parent = effect.parent;
				effect = effect.next;

				while (effect === null && parent !== null) {
					effect = parent.next;
					parent = parent.parent;
				}
			}
		}

		/**
		 * @param {Effect[]} effects
		 */
		#defer_effects(effects) {
			for (const e of effects) {
				const target = (e.f & DIRTY) !== 0 ? this.#dirty_effects : this.#maybe_dirty_effects;
				target.push(e);

				// mark as clean so they get scheduled if they depend on pending async state
				set_signal_status(e, CLEAN);
			}

			effects.length = 0;
		}

		/**
		 * Associate a change to a given source with the current
		 * batch, noting its previous and current values
		 * @param {Source} source
		 * @param {any} value
		 */
		capture(source, value) {
			if (!this.#previous.has(source)) {
				this.#previous.set(source, value);
			}

			this.current.set(source, source.v);
		}

		activate() {
			current_batch = this;
		}

		deactivate() {
			current_batch = null;
			previous_batch = null;

			for (const update of effect_pending_updates) {
				effect_pending_updates.delete(update);
				update();

				if (current_batch !== null) {
					// only do one at a time
					break;
				}
			}
		}

		flush() {
			if (queued_root_effects.length > 0) {
				this.activate();
				flush_effects();

				if (current_batch !== null && current_batch !== this) {
					// this can happen if a new batch was created during `flush_effects()`
					return;
				}
			} else if (this.#pending === 0) {
				this.#commit();
			}

			this.deactivate();
		}

		/**
		 * Append and remove branches to/from the DOM
		 */
		#commit() {
			for (const fn of this.#callbacks) {
				fn();
			}

			this.#callbacks.clear();

			// If there are other pending batches, they now need to be 'rebased' —
			// in other words, we re-run block/async effects with the newly
			// committed state, unless the batch in question has a more
			// recent value for a given source
			if (batches.size > 1) {
				this.#previous.clear();

				let is_earlier = true;

				for (const batch of batches) {
					if (batch === this) {
						is_earlier = false;
						continue;
					}

					for (const [source, value] of this.current) {
						if (batch.current.has(source)) {
							if (is_earlier) {
								// bring the value up to date
								batch.current.set(source, value);
							} else {
								// later batch has more recent value,
								// no need to re-run these effects
								continue;
							}
						}

						mark_effects(source);
					}

					if (queued_root_effects.length > 0) {
						current_batch = batch;
						const revert = Batch.apply(batch);

						for (const root of queued_root_effects) {
							batch.#traverse_effect_tree(root);
						}

						queued_root_effects = [];
						revert();
					}
				}

				current_batch = null;
			}

			batches.delete(this);
		}

		increment() {
			this.#pending += 1;
		}

		decrement() {
			this.#pending -= 1;

			if (this.#pending === 0) {
				for (const e of this.#dirty_effects) {
					set_signal_status(e, DIRTY);
					schedule_effect(e);
				}

				for (const e of this.#maybe_dirty_effects) {
					set_signal_status(e, MAYBE_DIRTY);
					schedule_effect(e);
				}

				this.flush();
			} else {
				this.deactivate();
			}
		}

		/** @param {() => void} fn */
		add_callback(fn) {
			this.#callbacks.add(fn);
		}

		settled() {
			return (this.#deferred ??= deferred()).promise;
		}

		static ensure() {
			if (current_batch === null) {
				const batch = (current_batch = new Batch());
				batches.add(current_batch);

				if (!is_flushing_sync) {
					Batch.enqueue(() => {
						if (current_batch !== batch) {
							// a flushSync happened in the meantime
							return;
						}

						batch.flush();
					});
				}
			}

			return current_batch;
		}

		/** @param {() => void} task */
		static enqueue(task) {
			queue_micro_task(task);
		}

		/**
		 * @param {Batch} current_batch
		 */
		static apply(current_batch) {
			{
				return noop;
			}
		}
	}

	/**
	 * Synchronously flush any pending updates.
	 * Returns void if no callback is provided, otherwise returns the result of calling the callback.
	 * @template [T=void]
	 * @param {(() => T) | undefined} [fn]
	 * @returns {T}
	 */
	function flushSync(fn) {

		var was_flushing_sync = is_flushing_sync;
		is_flushing_sync = true;

		try {
			var result;

			if (fn) {
				if (current_batch !== null) {
					flush_effects();
				}

				result = fn();
			}

			while (true) {
				flush_tasks();

				if (queued_root_effects.length === 0) {
					current_batch?.flush();

					// we need to check again, in case we just updated an `$effect.pending()`
					if (queued_root_effects.length === 0) {
						// this would be reset in `flush_effects()` but since we are early returning here,
						// we need to reset it here as well in case the first time there's 0 queued root effects
						last_scheduled_effect = null;

						return /** @type {T} */ (result);
					}
				}

				flush_effects();
			}
		} finally {
			is_flushing_sync = was_flushing_sync;
		}
	}

	function flush_effects() {
		var was_updating_effect = is_updating_effect;
		is_flushing = true;

		try {
			var flush_count = 0;
			set_is_updating_effect(true);

			while (queued_root_effects.length > 0) {
				var batch = Batch.ensure();

				if (flush_count++ > 1000) {
					if (DEV) {
						var updates = new Map();

						for (const source of batch.current.keys()) {
							for (const [stack, update] of source.updated ?? []) {
								var entry = updates.get(stack);

								if (!entry) {
									entry = { error: update.error, count: 0 };
									updates.set(stack, entry);
								}

								entry.count += update.count;
							}
						}

						for (const update of updates.values()) {
							// eslint-disable-next-line no-console
							console.error(update.error);
						}
					}

					infinite_loop_guard();
				}

				batch.process(queued_root_effects);
				old_values.clear();
			}
		} finally {
			is_flushing = false;
			set_is_updating_effect(was_updating_effect);

			last_scheduled_effect = null;
		}
	}

	function infinite_loop_guard() {
		try {
			effect_update_depth_exceeded();
		} catch (error) {
			if (DEV) {
				// stack contains no useful information, replace it
				define_property(error, 'stack', { value: '' });
			}

			// Best effort: invoke the boundary nearest the most recent
			// effect and hope that it's relevant to the infinite loop
			invoke_error_boundary(error, last_scheduled_effect);
		}
	}

	/** @type {Effect[] | null} */
	let eager_block_effects = null;

	/**
	 * @param {Array<Effect>} effects
	 * @returns {void}
	 */
	function flush_queued_effects(effects) {
		var length = effects.length;
		if (length === 0) return;

		var i = 0;

		while (i < length) {
			var effect = effects[i++];

			if ((effect.f & (DESTROYED | INERT)) === 0 && is_dirty(effect)) {
				eager_block_effects = [];

				update_effect(effect);

				// Effects with no dependencies or teardown do not get added to the effect tree.
				// Deferred effects (e.g. `$effect(...)`) _are_ added to the tree because we
				// don't know if we need to keep them until they are executed. Doing the check
				// here (rather than in `update_effect`) allows us to skip the work for
				// immediate effects.
				if (effect.deps === null && effect.first === null && effect.nodes_start === null) {
					// if there's no teardown or abort controller we completely unlink
					// the effect from the graph
					if (effect.teardown === null && effect.ac === null) {
						// remove this effect from the graph
						unlink_effect(effect);
					} else {
						// keep the effect in the graph, but free up some memory
						effect.fn = null;
					}
				}

				// If update_effect() has a flushSync() in it, we may have flushed another flush_queued_effects(),
				// which already handled this logic and did set eager_block_effects to null.
				if (eager_block_effects?.length > 0) {
					// TODO this feels incorrect! it gets the tests passing
					old_values.clear();

					for (const e of eager_block_effects) {
						update_effect(e);
					}

					eager_block_effects = [];
				}
			}
		}

		eager_block_effects = null;
	}

	/**
	 * This is similar to `mark_reactions`, but it only marks async/block effects
	 * so that these can re-run after another batch has been committed
	 * @param {Value} value
	 */
	function mark_effects(value) {
		if (value.reactions !== null) {
			for (const reaction of value.reactions) {
				const flags = reaction.f;

				if ((flags & DERIVED) !== 0) {
					mark_effects(/** @type {Derived} */ (reaction));
				} else if ((flags & (ASYNC | BLOCK_EFFECT)) !== 0) {
					set_signal_status(reaction, DIRTY);
					schedule_effect(/** @type {Effect} */ (reaction));
				}
			}
		}
	}

	/**
	 * @param {Effect} signal
	 * @returns {void}
	 */
	function schedule_effect(signal) {
		var effect = (last_scheduled_effect = signal);

		while (effect.parent !== null) {
			effect = effect.parent;
			var flags = effect.f;

			// if the effect is being scheduled because a parent (each/await/etc) block
			// updated an internal source, bail out or we'll cause a second flush
			if (is_flushing && effect === active_effect && (flags & BLOCK_EFFECT) !== 0) {
				return;
			}

			if ((flags & (ROOT_EFFECT | BRANCH_EFFECT)) !== 0) {
				if ((flags & CLEAN) === 0) return;
				effect.f ^= CLEAN;
			}
		}

		queued_root_effects.push(effect);
	}

	/** @import { Effect, Value } from '#client' */

	/**
	 *
	 * @param {Array<() => any>} sync
	 * @param {Array<() => Promise<any>>} async
	 * @param {(values: Value[]) => any} fn
	 */
	function flatten(sync, async, fn) {
		const d = is_runes() ? derived : derived_safe_equal;

		if (async.length === 0) {
			fn(sync.map(d));
			return;
		}

		var batch = current_batch;
		var parent = /** @type {Effect} */ (active_effect);

		var restore = capture();

		Promise.all(async.map((expression) => async_derived(expression)))
			.then((result) => {
				batch?.activate();

				restore();

				try {
					fn([...sync.map(d), ...result]);
				} catch (error) {
					// ignore errors in blocks that have already been destroyed
					if ((parent.f & DESTROYED) === 0) {
						invoke_error_boundary(error, parent);
					}
				}

				batch?.deactivate();
				unset_context();
			})
			.catch((error) => {
				invoke_error_boundary(error, parent);
			});
	}

	/**
	 * Captures the current effect context so that we can restore it after
	 * some asynchronous work has happened (so that e.g. `await a + b`
	 * causes `b` to be registered as a dependency).
	 */
	function capture() {
		var previous_effect = active_effect;
		var previous_reaction = active_reaction;
		var previous_component_context = component_context;
		var previous_batch = current_batch;

		return function restore() {
			set_active_effect(previous_effect);
			set_active_reaction(previous_reaction);
			set_component_context(previous_component_context);
			previous_batch?.activate();

			if (DEV) {
				set_from_async_derived(null);
			}
		};
	}

	function unset_context() {
		set_active_effect(null);
		set_active_reaction(null);
		set_component_context(null);
		if (DEV) set_from_async_derived(null);
	}

	/** @import { Derived, Effect, Source } from '#client' */

	/** @type {Effect | null} */
	let current_async_effect = null;

	/** @param {Effect | null} v */
	function set_from_async_derived(v) {
		current_async_effect = v;
	}

	const recent_async_deriveds = new Set();

	/**
	 * @template V
	 * @param {() => V} fn
	 * @returns {Derived<V>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function derived(fn) {
		var flags = DERIVED | DIRTY;
		var parent_derived =
			active_reaction !== null && (active_reaction.f & DERIVED) !== 0
				? /** @type {Derived} */ (active_reaction)
				: null;

		if (active_effect === null || (parent_derived !== null && (parent_derived.f & UNOWNED) !== 0)) {
			flags |= UNOWNED;
		} else {
			// Since deriveds are evaluated lazily, any effects created inside them are
			// created too late to ensure that the parent effect is added to the tree
			active_effect.f |= EFFECT_PRESERVED;
		}

		/** @type {Derived<V>} */
		const signal = {
			ctx: component_context,
			deps: null,
			effects: null,
			equals,
			f: flags,
			fn,
			reactions: null,
			rv: 0,
			v: /** @type {V} */ (UNINITIALIZED),
			wv: 0,
			parent: parent_derived ?? active_effect,
			ac: null
		};

		if (DEV && tracing_mode_flag) {
			signal.created = get_stack('CreatedAt');
		}

		return signal;
	}

	/**
	 * @template V
	 * @param {() => V | Promise<V>} fn
	 * @param {string} [location] If provided, print a warning if the value is not read immediately after update
	 * @returns {Promise<Source<V>>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function async_derived(fn, location) {
		let parent = /** @type {Effect | null} */ (active_effect);

		if (parent === null) {
			async_derived_orphan();
		}

		var boundary = /** @type {Boundary} */ (parent.b);

		var promise = /** @type {Promise<V>} */ (/** @type {unknown} */ (undefined));
		var signal = source(/** @type {V} */ (UNINITIALIZED));

		// only suspend in async deriveds created on initialisation
		var should_suspend = !active_reaction;

		/** @type {Map<Batch, ReturnType<typeof deferred<V>>>} */
		var deferreds = new Map();

		async_effect(() => {
			if (DEV) current_async_effect = active_effect;

			/** @type {ReturnType<typeof deferred<V>>} */
			var d = deferred();
			promise = d.promise;

			try {
				// If this code is changed at some point, make sure to still access the then property
				// of fn() to read any signals it might access, so that we track them as dependencies.
				Promise.resolve(fn()).then(d.resolve, d.reject);
			} catch (error) {
				d.reject(error);
			}

			if (DEV) current_async_effect = null;

			var batch = /** @type {Batch} */ (current_batch);
			var pending = boundary.is_pending();

			if (should_suspend) {
				boundary.update_pending_count(1);
				if (!pending) {
					batch.increment();

					deferreds.get(batch)?.reject(STALE_REACTION);
					deferreds.set(batch, d);
				}
			}

			/**
			 * @param {any} value
			 * @param {unknown} error
			 */
			const handler = (value, error = undefined) => {
				current_async_effect = null;

				if (!pending) batch.activate();

				if (error) {
					if (error !== STALE_REACTION) {
						signal.f |= ERROR_VALUE;

						// @ts-expect-error the error is the wrong type, but we don't care
						internal_set(signal, error);
					}
				} else {
					if ((signal.f & ERROR_VALUE) !== 0) {
						signal.f ^= ERROR_VALUE;
					}

					internal_set(signal, value);

					if (DEV && location !== undefined) {
						recent_async_deriveds.add(signal);

						setTimeout(() => {
							if (recent_async_deriveds.has(signal)) {
								await_waterfall(/** @type {string} */ (signal.label), location);
								recent_async_deriveds.delete(signal);
							}
						});
					}
				}

				if (should_suspend) {
					boundary.update_pending_count(-1);
					if (!pending) batch.decrement();
				}

				unset_context();
			};

			d.promise.then(handler, (e) => handler(null, e || 'unknown'));
		});

		teardown(() => {
			for (const d of deferreds.values()) {
				d.reject(STALE_REACTION);
			}
		});

		if (DEV) {
			// add a flag that lets this be printed as a derived
			// when using `$inspect.trace()`
			signal.f |= ASYNC;
		}

		return new Promise((fulfil) => {
			/** @param {Promise<V>} p */
			function next(p) {
				function go() {
					if (p === promise) {
						fulfil(signal);
					} else {
						// if the effect re-runs before the initial promise
						// resolves, delay resolution until we have a value
						next(promise);
					}
				}

				p.then(go, go);
			}

			next(promise);
		});
	}

	/**
	 * @template V
	 * @param {() => V} fn
	 * @returns {Derived<V>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function user_derived(fn) {
		const d = derived(fn);

		push_reaction_value(d);

		return d;
	}

	/**
	 * @template V
	 * @param {() => V} fn
	 * @returns {Derived<V>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function derived_safe_equal(fn) {
		const signal = derived(fn);
		signal.equals = safe_equals;
		return signal;
	}

	/**
	 * @param {Derived} derived
	 * @returns {void}
	 */
	function destroy_derived_effects(derived) {
		var effects = derived.effects;

		if (effects !== null) {
			derived.effects = null;

			for (var i = 0; i < effects.length; i += 1) {
				destroy_effect(/** @type {Effect} */ (effects[i]));
			}
		}
	}

	/**
	 * The currently updating deriveds, used to detect infinite recursion
	 * in dev mode and provide a nicer error than 'too much recursion'
	 * @type {Derived[]}
	 */
	let stack = [];

	/**
	 * @param {Derived} derived
	 * @returns {Effect | null}
	 */
	function get_derived_parent_effect(derived) {
		var parent = derived.parent;
		while (parent !== null) {
			if ((parent.f & DERIVED) === 0) {
				return /** @type {Effect} */ (parent);
			}
			parent = parent.parent;
		}
		return null;
	}

	/**
	 * @template T
	 * @param {Derived} derived
	 * @returns {T}
	 */
	function execute_derived(derived) {
		var value;
		var prev_active_effect = active_effect;

		set_active_effect(get_derived_parent_effect(derived));

		if (DEV) {
			let prev_inspect_effects = inspect_effects;
			set_inspect_effects(new Set());
			try {
				if (stack.includes(derived)) {
					derived_references_self();
				}

				stack.push(derived);

				destroy_derived_effects(derived);
				value = update_reaction(derived);
			} finally {
				set_active_effect(prev_active_effect);
				set_inspect_effects(prev_inspect_effects);
				stack.pop();
			}
		} else {
			try {
				destroy_derived_effects(derived);
				value = update_reaction(derived);
			} finally {
				set_active_effect(prev_active_effect);
			}
		}

		return value;
	}

	/**
	 * @param {Derived} derived
	 * @returns {void}
	 */
	function update_derived(derived) {
		var value = execute_derived(derived);

		if (!derived.equals(value)) {
			derived.v = value;
			derived.wv = increment_write_version();
		}

		// don't mark derived clean if we're reading it inside a
		// cleanup function, or it will cache a stale value
		if (is_destroying_effect) {
			return;
		}

		{
			var status =
				(skip_reaction || (derived.f & UNOWNED) !== 0) && derived.deps !== null ? MAYBE_DIRTY : CLEAN;

			set_signal_status(derived, status);
		}
	}

	/** @import { Derived, Effect, Source, Value } from '#client' */

	/** @type {Set<any>} */
	let inspect_effects = new Set();

	/** @type {Map<Source, any>} */
	const old_values = new Map();

	/**
	 * @param {Set<any>} v
	 */
	function set_inspect_effects(v) {
		inspect_effects = v;
	}

	let inspect_effects_deferred = false;

	function set_inspect_effects_deferred() {
		inspect_effects_deferred = true;
	}

	/**
	 * @template V
	 * @param {V} v
	 * @param {Error | null} [stack]
	 * @returns {Source<V>}
	 */
	// TODO rename this to `state` throughout the codebase
	function source(v, stack) {
		/** @type {Value} */
		var signal = {
			f: 0, // TODO ideally we could skip this altogether, but it causes type errors
			v,
			reactions: null,
			equals,
			rv: 0,
			wv: 0
		};

		if (DEV && tracing_mode_flag) {
			signal.created = stack ?? get_stack('CreatedAt');
			signal.updated = null;
			signal.set_during_effect = false;
			signal.trace = null;
		}

		return signal;
	}

	/**
	 * @template V
	 * @param {V} v
	 * @param {Error | null} [stack]
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function state(v, stack) {
		const s = source(v, stack);

		push_reaction_value(s);

		return s;
	}

	/**
	 * @template V
	 * @param {V} initial_value
	 * @param {boolean} [immutable]
	 * @returns {Source<V>}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function mutable_source(initial_value, immutable = false, trackable = true) {
		const s = source(initial_value);
		if (!immutable) {
			s.equals = safe_equals;
		}

		// bind the signal to the component context, in case we need to
		// track updates to trigger beforeUpdate/afterUpdate callbacks
		if (legacy_mode_flag && trackable && component_context !== null && component_context.l !== null) {
			(component_context.l.s ??= []).push(s);
		}

		return s;
	}

	/**
	 * @template V
	 * @param {Source<V>} source
	 * @param {V} value
	 * @param {boolean} [should_proxy]
	 * @returns {V}
	 */
	function set(source, value, should_proxy = false) {
		if (
			active_reaction !== null &&
			// since we are untracking the function inside `$inspect.with` we need to add this check
			// to ensure we error if state is set inside an inspect effect
			(!untracking || (active_reaction.f & INSPECT_EFFECT) !== 0) &&
			is_runes() &&
			(active_reaction.f & (DERIVED | BLOCK_EFFECT | ASYNC | INSPECT_EFFECT)) !== 0 &&
			!current_sources?.includes(source)
		) {
			state_unsafe_mutation();
		}

		let new_value = should_proxy ? proxy(value) : value;

		if (DEV) {
			tag_proxy(new_value, /** @type {string} */ (source.label));
		}

		return internal_set(source, new_value);
	}

	/**
	 * @template V
	 * @param {Source<V>} source
	 * @param {V} value
	 * @returns {V}
	 */
	function internal_set(source, value) {
		if (!source.equals(value)) {
			var old_value = source.v;

			if (is_destroying_effect) {
				old_values.set(source, value);
			} else {
				old_values.set(source, old_value);
			}

			source.v = value;

			var batch = Batch.ensure();
			batch.capture(source, old_value);

			if (DEV) {
				if (active_effect !== null) {
					const error = get_stack('UpdatedAt');

					if (error !== null) {
						source.updated ??= new Map();
						let entry = source.updated.get(error.stack);

						if (!entry) {
							entry = { error, count: 0 };
							source.updated.set(error.stack, entry);
						}

						entry.count++;
					}
				}

				if (active_effect !== null) {
					source.set_during_effect = true;
				}
			}

			if ((source.f & DERIVED) !== 0) {
				// if we are assigning to a dirty derived we set it to clean/maybe dirty but we also eagerly execute it to track the dependencies
				if ((source.f & DIRTY) !== 0) {
					execute_derived(/** @type {Derived} */ (source));
				}
				set_signal_status(source, (source.f & UNOWNED) === 0 ? CLEAN : MAYBE_DIRTY);
			}

			source.wv = increment_write_version();

			mark_reactions(source, DIRTY);

			// It's possible that the current reaction might not have up-to-date dependencies
			// whilst it's actively running. So in the case of ensuring it registers the reaction
			// properly for itself, we need to ensure the current effect actually gets
			// scheduled. i.e: `$effect(() => x++)`
			if (
				is_runes() &&
				active_effect !== null &&
				(active_effect.f & CLEAN) !== 0 &&
				(active_effect.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0
			) {
				if (untracked_writes === null) {
					set_untracked_writes([source]);
				} else {
					untracked_writes.push(source);
				}
			}

			if (DEV && inspect_effects.size > 0 && !inspect_effects_deferred) {
				flush_inspect_effects();
			}
		}

		return value;
	}

	function flush_inspect_effects() {
		inspect_effects_deferred = false;

		const inspects = Array.from(inspect_effects);

		for (const effect of inspects) {
			// Mark clean inspect-effects as maybe dirty and then check their dirtiness
			// instead of just updating the effects - this way we avoid overfiring.
			if ((effect.f & CLEAN) !== 0) {
				set_signal_status(effect, MAYBE_DIRTY);
			}

			if (is_dirty(effect)) {
				update_effect(effect);
			}
		}

		inspect_effects.clear();
	}

	/**
	 * Silently (without using `get`) increment a source
	 * @param {Source<number>} source
	 */
	function increment(source) {
		set(source, source.v + 1);
	}

	/**
	 * @param {Value} signal
	 * @param {number} status should be DIRTY or MAYBE_DIRTY
	 * @returns {void}
	 */
	function mark_reactions(signal, status) {
		var reactions = signal.reactions;
		if (reactions === null) return;

		var runes = is_runes();
		var length = reactions.length;

		for (var i = 0; i < length; i++) {
			var reaction = reactions[i];
			var flags = reaction.f;

			// In legacy mode, skip the current effect to prevent infinite loops
			if (!runes && reaction === active_effect) continue;

			// Inspect effects need to run immediately, so that the stack trace makes sense
			if (DEV && (flags & INSPECT_EFFECT) !== 0) {
				inspect_effects.add(reaction);
				continue;
			}

			var not_dirty = (flags & DIRTY) === 0;

			// don't set a DIRTY reaction to MAYBE_DIRTY
			if (not_dirty) {
				set_signal_status(reaction, status);
			}

			if ((flags & DERIVED) !== 0) {
				mark_reactions(/** @type {Derived} */ (reaction), MAYBE_DIRTY);
			} else if (not_dirty) {
				if ((flags & BLOCK_EFFECT) !== 0) {
					if (eager_block_effects !== null) {
						eager_block_effects.push(/** @type {Effect} */ (reaction));
					}
				}

				schedule_effect(/** @type {Effect} */ (reaction));
			}
		}
	}

	/** @import { Source } from '#client' */

	// TODO move all regexes into shared module?
	const regex_is_valid_identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;

	/**
	 * @template T
	 * @param {T} value
	 * @returns {T}
	 */
	function proxy(value) {
		// if non-proxyable, or is already a proxy, return `value`
		if (typeof value !== 'object' || value === null || STATE_SYMBOL in value) {
			return value;
		}

		const prototype = get_prototype_of(value);

		if (prototype !== object_prototype && prototype !== array_prototype) {
			return value;
		}

		/** @type {Map<any, Source<any>>} */
		var sources = new Map();
		var is_proxied_array = is_array(value);
		var version = state(0);

		var stack = DEV && tracing_mode_flag ? get_stack('CreatedAt') : null;
		var parent_version = update_version;

		/**
		 * Executes the proxy in the context of the reaction it was originally created in, if any
		 * @template T
		 * @param {() => T} fn
		 */
		var with_parent = (fn) => {
			if (update_version === parent_version) {
				return fn();
			}

			// child source is being created after the initial proxy —
			// prevent it from being associated with the current reaction
			var reaction = active_reaction;
			var version = update_version;

			set_active_reaction(null);
			set_update_version(parent_version);

			var result = fn();

			set_active_reaction(reaction);
			set_update_version(version);

			return result;
		};

		if (is_proxied_array) {
			// We need to create the length source eagerly to ensure that
			// mutations to the array are properly synced with our proxy
			sources.set('length', state(/** @type {any[]} */ (value).length, stack));
			if (DEV) {
				value = /** @type {any} */ (inspectable_array(/** @type {any[]} */ (value)));
			}
		}

		/** Used in dev for $inspect.trace() */
		var path = '';
		let updating = false;
		/** @param {string} new_path */
		function update_path(new_path) {
			if (updating) return;
			updating = true;
			path = new_path;

			tag(version, `${path} version`);

			// rename all child sources and child proxies
			for (const [prop, source] of sources) {
				tag(source, get_label(path, prop));
			}
			updating = false;
		}

		return new Proxy(/** @type {any} */ (value), {
			defineProperty(_, prop, descriptor) {
				if (
					!('value' in descriptor) ||
					descriptor.configurable === false ||
					descriptor.enumerable === false ||
					descriptor.writable === false
				) {
					// we disallow non-basic descriptors, because unless they are applied to the
					// target object — which we avoid, so that state can be forked — we will run
					// afoul of the various invariants
					// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/getOwnPropertyDescriptor#invariants
					state_descriptors_fixed();
				}
				var s = sources.get(prop);
				if (s === undefined) {
					s = with_parent(() => {
						var s = state(descriptor.value, stack);
						sources.set(prop, s);
						if (DEV && typeof prop === 'string') {
							tag(s, get_label(path, prop));
						}
						return s;
					});
				} else {
					set(s, descriptor.value, true);
				}

				return true;
			},

			deleteProperty(target, prop) {
				var s = sources.get(prop);

				if (s === undefined) {
					if (prop in target) {
						const s = with_parent(() => state(UNINITIALIZED, stack));
						sources.set(prop, s);
						increment(version);

						if (DEV) {
							tag(s, get_label(path, prop));
						}
					}
				} else {
					set(s, UNINITIALIZED);
					increment(version);
				}

				return true;
			},

			get(target, prop, receiver) {
				if (prop === STATE_SYMBOL) {
					return value;
				}

				if (DEV && prop === PROXY_PATH_SYMBOL) {
					return update_path;
				}

				var s = sources.get(prop);
				var exists = prop in target;

				// create a source, but only if it's an own property and not a prototype property
				if (s === undefined && (!exists || get_descriptor(target, prop)?.writable)) {
					s = with_parent(() => {
						var p = proxy(exists ? target[prop] : UNINITIALIZED);
						var s = state(p, stack);

						if (DEV) {
							tag(s, get_label(path, prop));
						}

						return s;
					});

					sources.set(prop, s);
				}

				if (s !== undefined) {
					var v = get$1(s);
					return v === UNINITIALIZED ? undefined : v;
				}

				return Reflect.get(target, prop, receiver);
			},

			getOwnPropertyDescriptor(target, prop) {
				var descriptor = Reflect.getOwnPropertyDescriptor(target, prop);

				if (descriptor && 'value' in descriptor) {
					var s = sources.get(prop);
					if (s) descriptor.value = get$1(s);
				} else if (descriptor === undefined) {
					var source = sources.get(prop);
					var value = source?.v;

					if (source !== undefined && value !== UNINITIALIZED) {
						return {
							enumerable: true,
							configurable: true,
							value,
							writable: true
						};
					}
				}

				return descriptor;
			},

			has(target, prop) {
				if (prop === STATE_SYMBOL) {
					return true;
				}

				var s = sources.get(prop);
				var has = (s !== undefined && s.v !== UNINITIALIZED) || Reflect.has(target, prop);

				if (
					s !== undefined ||
					(active_effect !== null && (!has || get_descriptor(target, prop)?.writable))
				) {
					if (s === undefined) {
						s = with_parent(() => {
							var p = has ? proxy(target[prop]) : UNINITIALIZED;
							var s = state(p, stack);

							if (DEV) {
								tag(s, get_label(path, prop));
							}

							return s;
						});

						sources.set(prop, s);
					}

					var value = get$1(s);
					if (value === UNINITIALIZED) {
						return false;
					}
				}

				return has;
			},

			set(target, prop, value, receiver) {
				var s = sources.get(prop);
				var has = prop in target;

				// variable.length = value -> clear all signals with index >= value
				if (is_proxied_array && prop === 'length') {
					for (var i = value; i < /** @type {Source<number>} */ (s).v; i += 1) {
						var other_s = sources.get(i + '');
						if (other_s !== undefined) {
							set(other_s, UNINITIALIZED);
						} else if (i in target) {
							// If the item exists in the original, we need to create a uninitialized source,
							// else a later read of the property would result in a source being created with
							// the value of the original item at that index.
							other_s = with_parent(() => state(UNINITIALIZED, stack));
							sources.set(i + '', other_s);

							if (DEV) {
								tag(other_s, get_label(path, i));
							}
						}
					}
				}

				// If we haven't yet created a source for this property, we need to ensure
				// we do so otherwise if we read it later, then the write won't be tracked and
				// the heuristics of effects will be different vs if we had read the proxied
				// object property before writing to that property.
				if (s === undefined) {
					if (!has || get_descriptor(target, prop)?.writable) {
						s = with_parent(() => state(undefined, stack));

						if (DEV) {
							tag(s, get_label(path, prop));
						}
						set(s, proxy(value));

						sources.set(prop, s);
					}
				} else {
					has = s.v !== UNINITIALIZED;

					var p = with_parent(() => proxy(value));
					set(s, p);
				}

				var descriptor = Reflect.getOwnPropertyDescriptor(target, prop);

				// Set the new value before updating any signals so that any listeners get the new value
				if (descriptor?.set) {
					descriptor.set.call(receiver, value);
				}

				if (!has) {
					// If we have mutated an array directly, we might need to
					// signal that length has also changed. Do it before updating metadata
					// to ensure that iterating over the array as a result of a metadata update
					// will not cause the length to be out of sync.
					if (is_proxied_array && typeof prop === 'string') {
						var ls = /** @type {Source<number>} */ (sources.get('length'));
						var n = Number(prop);

						if (Number.isInteger(n) && n >= ls.v) {
							set(ls, n + 1);
						}
					}

					increment(version);
				}

				return true;
			},

			ownKeys(target) {
				get$1(version);

				var own_keys = Reflect.ownKeys(target).filter((key) => {
					var source = sources.get(key);
					return source === undefined || source.v !== UNINITIALIZED;
				});

				for (var [key, source] of sources) {
					if (source.v !== UNINITIALIZED && !(key in target)) {
						own_keys.push(key);
					}
				}

				return own_keys;
			},

			setPrototypeOf() {
				state_prototype_fixed();
			}
		});
	}

	/**
	 * @param {string} path
	 * @param {string | symbol} prop
	 */
	function get_label(path, prop) {
		if (typeof prop === 'symbol') return `${path}[Symbol(${prop.description ?? ''})]`;
		if (regex_is_valid_identifier.test(prop)) return `${path}.${prop}`;
		return /^\d+$/.test(prop) ? `${path}[${prop}]` : `${path}['${prop}']`;
	}

	/**
	 * @param {any} value
	 */
	function get_proxied_value(value) {
		try {
			if (value !== null && typeof value === 'object' && STATE_SYMBOL in value) {
				return value[STATE_SYMBOL];
			}
		} catch {
			// the above if check can throw an error if the value in question
			// is the contentWindow of an iframe on another domain, in which
			// case we want to just return the value (because it's definitely
			// not a proxied value) so we don't break any JavaScript interacting
			// with that iframe (such as various payment companies client side
			// JavaScript libraries interacting with their iframes on the same
			// domain)
		}

		return value;
	}

	const ARRAY_MUTATING_METHODS = new Set([
		'copyWithin',
		'fill',
		'pop',
		'push',
		'reverse',
		'shift',
		'sort',
		'splice',
		'unshift'
	]);

	/**
	 * Wrap array mutating methods so $inspect is triggered only once and
	 * to prevent logging an array in intermediate state (e.g. with an empty slot)
	 * @param {any[]} array
	 */
	function inspectable_array(array) {
		return new Proxy(array, {
			get(target, prop, receiver) {
				var value = Reflect.get(target, prop, receiver);
				if (!ARRAY_MUTATING_METHODS.has(/** @type {string} */ (prop))) {
					return value;
				}

				/**
				 * @this {any[]}
				 * @param {any[]} args
				 */
				return function (...args) {
					set_inspect_effects_deferred();
					var result = value.apply(this, args);
					flush_inspect_effects();
					return result;
				};
			}
		});
	}

	/**
	 * @param {any} a
	 * @param {any} b
	 * @param {boolean} equal
	 * @returns {boolean}
	 */
	function strict_equals(a, b, equal = true) {
		// try-catch needed because this tries to read properties of `a` and `b`,
		// which could be disallowed for example in a secure context
		try {
			if ((a === b) !== (get_proxied_value(a) === get_proxied_value(b))) {
				state_proxy_equality_mismatch(equal ? '===' : '!==');
			}
		} catch {}

		return (a === b) === equal;
	}

	/** @import { Effect, TemplateNode } from '#client' */

	/** @type {boolean} */
	var is_firefox;

	/** @type {() => Node | null} */
	var first_child_getter;
	/** @type {() => Node | null} */
	var next_sibling_getter;

	/**
	 * @param {string} value
	 * @returns {Text}
	 */
	function create_text(value = '') {
		return document.createTextNode(value);
	}

	/**
	 * @template {Node} N
	 * @param {N} node
	 * @returns {Node | null}
	 */
	/*@__NO_SIDE_EFFECTS__*/
	function get_first_child(node) {
		return first_child_getter.call(node);
	}

	/**
	 * @template {Node} N
	 * @param {N} node
	 * @returns {Node | null}
	 */
	/*@__NO_SIDE_EFFECTS__*/
	function get_next_sibling(node) {
		return next_sibling_getter.call(node);
	}

	/**
	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
	 * @template {Node} N
	 * @param {N} node
	 * @param {boolean} is_text
	 * @returns {Node | null}
	 */
	function child(node, is_text) {
		{
			return get_first_child(node);
		}
	}

	/**
	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
	 * @param {DocumentFragment | TemplateNode | TemplateNode[]} fragment
	 * @param {boolean} [is_text]
	 * @returns {Node | null}
	 */
	function first_child(fragment, is_text = false) {
		{
			// when not hydrating, `fragment` is a `DocumentFragment` (the result of calling `open_frag`)
			var first = /** @type {DocumentFragment} */ (get_first_child(/** @type {Node} */ (fragment)));

			// TODO prevent user comments with the empty string when preserveComments is true
			if (first instanceof Comment && first.data === '') return get_next_sibling(first);

			return first;
		}
	}

	/**
	 * Don't mark this as side-effect-free, hydration needs to walk all nodes
	 * @param {TemplateNode} node
	 * @param {number} count
	 * @param {boolean} is_text
	 * @returns {Node | null}
	 */
	function sibling(node, count = 1, is_text = false) {
		let next_sibling = node;

		while (count--) {
			next_sibling = /** @type {TemplateNode} */ (get_next_sibling(next_sibling));
		}

		{
			return next_sibling;
		}
	}

	/**
	 * @template {Node} N
	 * @param {N} node
	 * @returns {void}
	 */
	function clear_text_content(node) {
		node.textContent = '';
	}

	/**
	 * Returns `true` if we're updating the current block, for example `condition` in
	 * an `{#if condition}` block just changed. In this case, the branch should be
	 * appended (or removed) at the same time as other updates within the
	 * current `<svelte:boundary>`
	 */
	function should_defer_append() {
		return false;
	}

	let listening_to_form_reset = false;

	function add_form_reset_listener() {
		if (!listening_to_form_reset) {
			listening_to_form_reset = true;
			document.addEventListener(
				'reset',
				(evt) => {
					// Needs to happen one tick later or else the dom properties of the form
					// elements have not updated to their reset values yet
					Promise.resolve().then(() => {
						if (!evt.defaultPrevented) {
							for (const e of /**@type {HTMLFormElement} */ (evt.target).elements) {
								// @ts-expect-error
								e.__on_r?.();
							}
						}
					});
				},
				// In the capture phase to guarantee we get noticed of it (no possiblity of stopPropagation)
				{ capture: true }
			);
		}
	}

	/**
	 * @template T
	 * @param {() => T} fn
	 */
	function without_reactive_context(fn) {
		var previous_reaction = active_reaction;
		var previous_effect = active_effect;
		set_active_reaction(null);
		set_active_effect(null);
		try {
			return fn();
		} finally {
			set_active_reaction(previous_reaction);
			set_active_effect(previous_effect);
		}
	}

	/**
	 * Listen to the given event, and then instantiate a global form reset listener if not already done,
	 * to notify all bindings when the form is reset
	 * @param {HTMLElement} element
	 * @param {string} event
	 * @param {(is_reset?: true) => void} handler
	 * @param {(is_reset?: true) => void} [on_reset]
	 */
	function listen_to_event_and_reset_event(element, event, handler, on_reset = handler) {
		element.addEventListener(event, () => without_reactive_context(handler));
		// @ts-expect-error
		const prev = element.__on_r;
		if (prev) {
			// special case for checkbox that can have multiple binds (group & checked)
			// @ts-expect-error
			element.__on_r = () => {
				prev();
				on_reset(true);
			};
		} else {
			// @ts-expect-error
			element.__on_r = () => on_reset(true);
		}

		add_form_reset_listener();
	}

	/** @import { ComponentContext, ComponentContextLegacy, Derived, Effect, TemplateNode, TransitionManager } from '#client' */

	/**
	 * @param {'$effect' | '$effect.pre' | '$inspect'} rune
	 */
	function validate_effect(rune) {
		if (active_effect === null && active_reaction === null) {
			effect_orphan(rune);
		}

		if (active_reaction !== null && (active_reaction.f & UNOWNED) !== 0 && active_effect === null) {
			effect_in_unowned_derived();
		}

		if (is_destroying_effect) {
			effect_in_teardown(rune);
		}
	}

	/**
	 * @param {Effect} effect
	 * @param {Effect} parent_effect
	 */
	function push_effect(effect, parent_effect) {
		var parent_last = parent_effect.last;
		if (parent_last === null) {
			parent_effect.last = parent_effect.first = effect;
		} else {
			parent_last.next = effect;
			effect.prev = parent_last;
			parent_effect.last = effect;
		}
	}

	/**
	 * @param {number} type
	 * @param {null | (() => void | (() => void))} fn
	 * @param {boolean} sync
	 * @param {boolean} push
	 * @returns {Effect}
	 */
	function create_effect(type, fn, sync, push = true) {
		var parent = active_effect;

		if (DEV) {
			// Ensure the parent is never an inspect effect
			while (parent !== null && (parent.f & INSPECT_EFFECT) !== 0) {
				parent = parent.parent;
			}
		}

		if (parent !== null && (parent.f & INERT) !== 0) {
			type |= INERT;
		}

		/** @type {Effect} */
		var effect = {
			ctx: component_context,
			deps: null,
			nodes_start: null,
			nodes_end: null,
			f: type | DIRTY,
			first: null,
			fn,
			last: null,
			next: null,
			parent,
			b: parent && parent.b,
			prev: null,
			teardown: null,
			transitions: null,
			wv: 0,
			ac: null
		};

		if (DEV) {
			effect.component_function = dev_current_component_function;
		}

		if (sync) {
			try {
				update_effect(effect);
				effect.f |= EFFECT_RAN;
			} catch (e) {
				destroy_effect(effect);
				throw e;
			}
		} else if (fn !== null) {
			schedule_effect(effect);
		}

		if (push) {
			/** @type {Effect | null} */
			var e = effect;

			// if an effect has already ran and doesn't need to be kept in the tree
			// (because it won't re-run, has no DOM, and has no teardown etc)
			// then we skip it and go to its child (if any)
			if (
				sync &&
				e.deps === null &&
				e.teardown === null &&
				e.nodes_start === null &&
				e.first === e.last && // either `null`, or a singular child
				(e.f & EFFECT_PRESERVED) === 0
			) {
				e = e.first;
			}

			if (e !== null) {
				e.parent = parent;

				if (parent !== null) {
					push_effect(e, parent);
				}

				// if we're in a derived, add the effect there too
				if (
					active_reaction !== null &&
					(active_reaction.f & DERIVED) !== 0 &&
					(type & ROOT_EFFECT) === 0
				) {
					var derived = /** @type {Derived} */ (active_reaction);
					(derived.effects ??= []).push(e);
				}
			}
		}

		return effect;
	}

	/**
	 * @param {() => void} fn
	 */
	function teardown(fn) {
		const effect = create_effect(RENDER_EFFECT, null, false);
		set_signal_status(effect, CLEAN);
		effect.teardown = fn;
		return effect;
	}

	/**
	 * Internal representation of `$effect(...)`
	 * @param {() => void | (() => void)} fn
	 */
	function user_effect(fn) {
		validate_effect('$effect');

		if (DEV) {
			define_property(fn, 'name', {
				value: '$effect'
			});
		}

		// Non-nested `$effect(...)` in a component should be deferred
		// until the component is mounted
		var flags = /** @type {Effect} */ (active_effect).f;
		var defer = !active_reaction && (flags & BRANCH_EFFECT) !== 0 && (flags & EFFECT_RAN) === 0;

		if (defer) {
			// Top-level `$effect(...)` in an unmounted component — defer until mount
			var context = /** @type {ComponentContext} */ (component_context);
			(context.e ??= []).push(fn);
		} else {
			// Everything else — create immediately
			return create_user_effect(fn);
		}
	}

	/**
	 * @param {() => void | (() => void)} fn
	 */
	function create_user_effect(fn) {
		return create_effect(EFFECT | USER_EFFECT, fn, false);
	}

	/**
	 * Internal representation of `$effect.pre(...)`
	 * @param {() => void | (() => void)} fn
	 * @returns {Effect}
	 */
	function user_pre_effect(fn) {
		validate_effect('$effect.pre');
		if (DEV) {
			define_property(fn, 'name', {
				value: '$effect.pre'
			});
		}
		return create_effect(RENDER_EFFECT | USER_EFFECT, fn, true);
	}

	/**
	 * Internal representation of `$: ..`
	 * @param {() => any} deps
	 * @param {() => void | (() => void)} fn
	 */
	function legacy_pre_effect(deps, fn) {
		var context = /** @type {ComponentContextLegacy} */ (component_context);

		/** @type {{ effect: null | Effect, ran: boolean, deps: () => any }} */
		var token = { effect: null, ran: false, deps };

		context.l.$.push(token);

		token.effect = render_effect(() => {
			deps();

			// If this legacy pre effect has already run before the end of the reset, then
			// bail out to emulate the same behavior.
			if (token.ran) return;

			token.ran = true;
			untrack(fn);
		});
	}

	function legacy_pre_effect_reset() {
		var context = /** @type {ComponentContextLegacy} */ (component_context);

		render_effect(() => {
			// Run dirty `$:` statements
			for (var token of context.l.$) {
				token.deps();

				var effect = token.effect;

				// If the effect is CLEAN, then make it MAYBE_DIRTY. This ensures we traverse through
				// the effects dependencies and correctly ensure each dependency is up-to-date.
				if ((effect.f & CLEAN) !== 0) {
					set_signal_status(effect, MAYBE_DIRTY);
				}

				if (is_dirty(effect)) {
					update_effect(effect);
				}

				token.ran = false;
			}
		});
	}

	/**
	 * @param {() => void | (() => void)} fn
	 * @returns {Effect}
	 */
	function async_effect(fn) {
		return create_effect(ASYNC | EFFECT_PRESERVED, fn, true);
	}

	/**
	 * @param {() => void | (() => void)} fn
	 * @returns {Effect}
	 */
	function render_effect(fn, flags = 0) {
		return create_effect(RENDER_EFFECT | flags, fn, true);
	}

	/**
	 * @param {(...expressions: any) => void | (() => void)} fn
	 * @param {Array<() => any>} sync
	 * @param {Array<() => Promise<any>>} async
	 */
	function template_effect(fn, sync = [], async = []) {
		flatten(sync, async, (values) => {
			create_effect(RENDER_EFFECT, () => fn(...values.map(get$1)), true);
		});
	}

	/**
	 * @param {(() => void)} fn
	 * @param {number} flags
	 */
	function block(fn, flags = 0) {
		var effect = create_effect(BLOCK_EFFECT | flags, fn, true);
		if (DEV) {
			effect.dev_stack = dev_stack;
		}
		return effect;
	}

	/**
	 * @param {(() => void)} fn
	 * @param {boolean} [push]
	 */
	function branch(fn, push = true) {
		return create_effect(BRANCH_EFFECT | EFFECT_PRESERVED, fn, true, push);
	}

	/**
	 * @param {Effect} effect
	 */
	function execute_effect_teardown(effect) {
		var teardown = effect.teardown;
		if (teardown !== null) {
			const previously_destroying_effect = is_destroying_effect;
			const previous_reaction = active_reaction;
			set_is_destroying_effect(true);
			set_active_reaction(null);
			try {
				teardown.call(null);
			} finally {
				set_is_destroying_effect(previously_destroying_effect);
				set_active_reaction(previous_reaction);
			}
		}
	}

	/**
	 * @param {Effect} signal
	 * @param {boolean} remove_dom
	 * @returns {void}
	 */
	function destroy_effect_children(signal, remove_dom = false) {
		var effect = signal.first;
		signal.first = signal.last = null;

		while (effect !== null) {
			const controller = effect.ac;

			if (controller !== null) {
				without_reactive_context(() => {
					controller.abort(STALE_REACTION);
				});
			}

			var next = effect.next;

			if ((effect.f & ROOT_EFFECT) !== 0) {
				// this is now an independent root
				effect.parent = null;
			} else {
				destroy_effect(effect, remove_dom);
			}

			effect = next;
		}
	}

	/**
	 * @param {Effect} signal
	 * @returns {void}
	 */
	function destroy_block_effect_children(signal) {
		var effect = signal.first;

		while (effect !== null) {
			var next = effect.next;
			if ((effect.f & BRANCH_EFFECT) === 0) {
				destroy_effect(effect);
			}
			effect = next;
		}
	}

	/**
	 * @param {Effect} effect
	 * @param {boolean} [remove_dom]
	 * @returns {void}
	 */
	function destroy_effect(effect, remove_dom = true) {
		var removed = false;

		if (
			(remove_dom || (effect.f & HEAD_EFFECT) !== 0) &&
			effect.nodes_start !== null &&
			effect.nodes_end !== null
		) {
			remove_effect_dom(effect.nodes_start, /** @type {TemplateNode} */ (effect.nodes_end));
			removed = true;
		}

		destroy_effect_children(effect, remove_dom && !removed);
		remove_reactions(effect, 0);
		set_signal_status(effect, DESTROYED);

		var transitions = effect.transitions;

		if (transitions !== null) {
			for (const transition of transitions) {
				transition.stop();
			}
		}

		execute_effect_teardown(effect);

		var parent = effect.parent;

		// If the parent doesn't have any children, then skip this work altogether
		if (parent !== null && parent.first !== null) {
			unlink_effect(effect);
		}

		if (DEV) {
			effect.component_function = null;
		}

		// `first` and `child` are nulled out in destroy_effect_children
		// we don't null out `parent` so that error propagation can work correctly
		effect.next =
			effect.prev =
			effect.teardown =
			effect.ctx =
			effect.deps =
			effect.fn =
			effect.nodes_start =
			effect.nodes_end =
			effect.ac =
				null;
	}

	/**
	 *
	 * @param {TemplateNode | null} node
	 * @param {TemplateNode} end
	 */
	function remove_effect_dom(node, end) {
		while (node !== null) {
			/** @type {TemplateNode | null} */
			var next = node === end ? null : /** @type {TemplateNode} */ (get_next_sibling(node));

			node.remove();
			node = next;
		}
	}

	/**
	 * Detach an effect from the effect tree, freeing up memory and
	 * reducing the amount of work that happens on subsequent traversals
	 * @param {Effect} effect
	 */
	function unlink_effect(effect) {
		var parent = effect.parent;
		var prev = effect.prev;
		var next = effect.next;

		if (prev !== null) prev.next = next;
		if (next !== null) next.prev = prev;

		if (parent !== null) {
			if (parent.first === effect) parent.first = next;
			if (parent.last === effect) parent.last = prev;
		}
	}

	/**
	 * When a block effect is removed, we don't immediately destroy it or yank it
	 * out of the DOM, because it might have transitions. Instead, we 'pause' it.
	 * It stays around (in memory, and in the DOM) until outro transitions have
	 * completed, and if the state change is reversed then we _resume_ it.
	 * A paused effect does not update, and the DOM subtree becomes inert.
	 * @param {Effect} effect
	 * @param {() => void} [callback]
	 */
	function pause_effect(effect, callback) {
		/** @type {TransitionManager[]} */
		var transitions = [];

		pause_children(effect, transitions, true);

		run_out_transitions(transitions, () => {
			destroy_effect(effect);
			if (callback) callback();
		});
	}

	/**
	 * @param {TransitionManager[]} transitions
	 * @param {() => void} fn
	 */
	function run_out_transitions(transitions, fn) {
		var remaining = transitions.length;
		if (remaining > 0) {
			var check = () => --remaining || fn();
			for (var transition of transitions) {
				transition.out(check);
			}
		} else {
			fn();
		}
	}

	/**
	 * @param {Effect} effect
	 * @param {TransitionManager[]} transitions
	 * @param {boolean} local
	 */
	function pause_children(effect, transitions, local) {
		if ((effect.f & INERT) !== 0) return;
		effect.f ^= INERT;

		if (effect.transitions !== null) {
			for (const transition of effect.transitions) {
				if (transition.is_global || local) {
					transitions.push(transition);
				}
			}
		}

		var child = effect.first;

		while (child !== null) {
			var sibling = child.next;
			var transparent = (child.f & EFFECT_TRANSPARENT) !== 0 || (child.f & BRANCH_EFFECT) !== 0;
			// TODO we don't need to call pause_children recursively with a linked list in place
			// it's slightly more involved though as we have to account for `transparent` changing
			// through the tree.
			pause_children(child, transitions, transparent ? local : false);
			child = sibling;
		}
	}

	/**
	 * The opposite of `pause_effect`. We call this if (for example)
	 * `x` becomes falsy then truthy: `{#if x}...{/if}`
	 * @param {Effect} effect
	 */
	function resume_effect(effect) {
		resume_children(effect, true);
	}

	/**
	 * @param {Effect} effect
	 * @param {boolean} local
	 */
	function resume_children(effect, local) {
		if ((effect.f & INERT) === 0) return;
		effect.f ^= INERT;

		// If a dependency of this effect changed while it was paused,
		// schedule the effect to update. we don't use `is_dirty`
		// here because we don't want to eagerly recompute a derived like
		// `{#if foo}{foo.bar()}{/if}` if `foo` is now `undefined
		if ((effect.f & CLEAN) === 0) {
			set_signal_status(effect, DIRTY);
			schedule_effect(effect);
		}

		var child = effect.first;

		while (child !== null) {
			var sibling = child.next;
			var transparent = (child.f & EFFECT_TRANSPARENT) !== 0 || (child.f & BRANCH_EFFECT) !== 0;
			// TODO we don't need to call resume_children recursively with a linked list in place
			// it's slightly more involved though as we have to account for `transparent` changing
			// through the tree.
			resume_children(child, transparent ? local : false);
			child = sibling;
		}

		if (effect.transitions !== null) {
			for (const transition of effect.transitions) {
				if (transition.is_global || local) {
					transition.in();
				}
			}
		}
	}

	/** @import { Value } from '#client' */

	/**
	 * @type {Set<Value> | null}
	 * @deprecated
	 */
	let captured_signals = null;

	/** @import { Derived, Effect, Reaction, Signal, Source, Value } from '#client' */

	let is_updating_effect = false;

	/** @param {boolean} value */
	function set_is_updating_effect(value) {
		is_updating_effect = value;
	}

	let is_destroying_effect = false;

	/** @param {boolean} value */
	function set_is_destroying_effect(value) {
		is_destroying_effect = value;
	}

	/** @type {null | Reaction} */
	let active_reaction = null;

	let untracking = false;

	/** @param {null | Reaction} reaction */
	function set_active_reaction(reaction) {
		active_reaction = reaction;
	}

	/** @type {null | Effect} */
	let active_effect = null;

	/** @param {null | Effect} effect */
	function set_active_effect(effect) {
		active_effect = effect;
	}

	/**
	 * When sources are created within a reaction, reading and writing
	 * them within that reaction should not cause a re-run
	 * @type {null | Source[]}
	 */
	let current_sources = null;

	/** @param {Value} value */
	function push_reaction_value(value) {
		if (active_reaction !== null && (!async_mode_flag )) {
			if (current_sources === null) {
				current_sources = [value];
			} else {
				current_sources.push(value);
			}
		}
	}

	/**
	 * The dependencies of the reaction that is currently being executed. In many cases,
	 * the dependencies are unchanged between runs, and so this will be `null` unless
	 * and until a new dependency is accessed — we track this via `skipped_deps`
	 * @type {null | Value[]}
	 */
	let new_deps = null;

	let skipped_deps = 0;

	/**
	 * Tracks writes that the effect it's executed in doesn't listen to yet,
	 * so that the dependency can be added to the effect later on if it then reads it
	 * @type {null | Source[]}
	 */
	let untracked_writes = null;

	/** @param {null | Source[]} value */
	function set_untracked_writes(value) {
		untracked_writes = value;
	}

	/**
	 * @type {number} Used by sources and deriveds for handling updates.
	 * Version starts from 1 so that unowned deriveds differentiate between a created effect and a run one for tracing
	 **/
	let write_version = 1;

	/** @type {number} Used to version each read of a source of derived to avoid duplicating depedencies inside a reaction */
	let read_version = 0;

	let update_version = read_version;

	/** @param {number} value */
	function set_update_version(value) {
		update_version = value;
	}

	// If we are working with a get() chain that has no active container,
	// to prevent memory leaks, we skip adding the reaction.
	let skip_reaction = false;

	function increment_write_version() {
		return ++write_version;
	}

	/**
	 * Determines whether a derived or effect is dirty.
	 * If it is MAYBE_DIRTY, will set the status to CLEAN
	 * @param {Reaction} reaction
	 * @returns {boolean}
	 */
	function is_dirty(reaction) {
		var flags = reaction.f;

		if ((flags & DIRTY) !== 0) {
			return true;
		}

		if ((flags & MAYBE_DIRTY) !== 0) {
			var dependencies = reaction.deps;
			var is_unowned = (flags & UNOWNED) !== 0;

			if (dependencies !== null) {
				var i;
				var dependency;
				var is_disconnected = (flags & DISCONNECTED) !== 0;
				var is_unowned_connected = is_unowned && active_effect !== null && !skip_reaction;
				var length = dependencies.length;

				// If we are working with a disconnected or an unowned signal that is now connected (due to an active effect)
				// then we need to re-connect the reaction to the dependency, unless the effect has already been destroyed
				// (which can happen if the derived is read by an async derived)
				if (
					(is_disconnected || is_unowned_connected) &&
					(active_effect === null || (active_effect.f & DESTROYED) === 0)
				) {
					var derived = /** @type {Derived} */ (reaction);
					var parent = derived.parent;

					for (i = 0; i < length; i++) {
						dependency = dependencies[i];

						// We always re-add all reactions (even duplicates) if the derived was
						// previously disconnected, however we don't if it was unowned as we
						// de-duplicate dependencies in that case
						if (is_disconnected || !dependency?.reactions?.includes(derived)) {
							(dependency.reactions ??= []).push(derived);
						}
					}

					if (is_disconnected) {
						derived.f ^= DISCONNECTED;
					}
					// If the unowned derived is now fully connected to the graph again (it's unowned and reconnected, has a parent
					// and the parent is not unowned), then we can mark it as connected again, removing the need for the unowned
					// flag
					if (is_unowned_connected && parent !== null && (parent.f & UNOWNED) === 0) {
						derived.f ^= UNOWNED;
					}
				}

				for (i = 0; i < length; i++) {
					dependency = dependencies[i];

					if (is_dirty(/** @type {Derived} */ (dependency))) {
						update_derived(/** @type {Derived} */ (dependency));
					}

					if (dependency.wv > reaction.wv) {
						return true;
					}
				}
			}

			// Unowned signals should never be marked as clean unless they
			// are used within an active_effect without skip_reaction
			if (!is_unowned || (active_effect !== null && !skip_reaction)) {
				set_signal_status(reaction, CLEAN);
			}
		}

		return false;
	}

	/**
	 * @param {Value} signal
	 * @param {Effect} effect
	 * @param {boolean} [root]
	 */
	function schedule_possible_effect_self_invalidation(signal, effect, root = true) {
		var reactions = signal.reactions;
		if (reactions === null) return;

		if (current_sources?.includes(signal)) {
			return;
		}

		for (var i = 0; i < reactions.length; i++) {
			var reaction = reactions[i];

			if ((reaction.f & DERIVED) !== 0) {
				schedule_possible_effect_self_invalidation(/** @type {Derived} */ (reaction), effect, false);
			} else if (effect === reaction) {
				if (root) {
					set_signal_status(reaction, DIRTY);
				} else if ((reaction.f & CLEAN) !== 0) {
					set_signal_status(reaction, MAYBE_DIRTY);
				}
				schedule_effect(/** @type {Effect} */ (reaction));
			}
		}
	}

	/** @param {Reaction} reaction */
	function update_reaction(reaction) {
		var previous_deps = new_deps;
		var previous_skipped_deps = skipped_deps;
		var previous_untracked_writes = untracked_writes;
		var previous_reaction = active_reaction;
		var previous_skip_reaction = skip_reaction;
		var previous_sources = current_sources;
		var previous_component_context = component_context;
		var previous_untracking = untracking;
		var previous_update_version = update_version;

		var flags = reaction.f;

		new_deps = /** @type {null | Value[]} */ (null);
		skipped_deps = 0;
		untracked_writes = null;
		skip_reaction =
			(flags & UNOWNED) !== 0 && (untracking || !is_updating_effect || active_reaction === null);
		active_reaction = (flags & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? reaction : null;

		current_sources = null;
		set_component_context(reaction.ctx);
		untracking = false;
		update_version = ++read_version;

		if (reaction.ac !== null) {
			without_reactive_context(() => {
				/** @type {AbortController} */ (reaction.ac).abort(STALE_REACTION);
			});

			reaction.ac = null;
		}

		try {
			reaction.f |= REACTION_IS_UPDATING;
			var fn = /** @type {Function} */ (reaction.fn);
			var result = fn();
			var deps = reaction.deps;

			if (new_deps !== null) {
				var i;

				remove_reactions(reaction, skipped_deps);

				if (deps !== null && skipped_deps > 0) {
					deps.length = skipped_deps + new_deps.length;
					for (i = 0; i < new_deps.length; i++) {
						deps[skipped_deps + i] = new_deps[i];
					}
				} else {
					reaction.deps = deps = new_deps;
				}

				if (
					!skip_reaction ||
					// Deriveds that already have reactions can cleanup, so we still add them as reactions
					((flags & DERIVED) !== 0 &&
						/** @type {import('#client').Derived} */ (reaction).reactions !== null)
				) {
					for (i = skipped_deps; i < deps.length; i++) {
						(deps[i].reactions ??= []).push(reaction);
					}
				}
			} else if (deps !== null && skipped_deps < deps.length) {
				remove_reactions(reaction, skipped_deps);
				deps.length = skipped_deps;
			}

			// If we're inside an effect and we have untracked writes, then we need to
			// ensure that if any of those untracked writes result in re-invalidation
			// of the current effect, then that happens accordingly
			if (
				is_runes() &&
				untracked_writes !== null &&
				!untracking &&
				deps !== null &&
				(reaction.f & (DERIVED | MAYBE_DIRTY | DIRTY)) === 0
			) {
				for (i = 0; i < /** @type {Source[]} */ (untracked_writes).length; i++) {
					schedule_possible_effect_self_invalidation(
						untracked_writes[i],
						/** @type {Effect} */ (reaction)
					);
				}
			}

			// If we are returning to an previous reaction then
			// we need to increment the read version to ensure that
			// any dependencies in this reaction aren't marked with
			// the same version
			if (previous_reaction !== null && previous_reaction !== reaction) {
				read_version++;

				if (untracked_writes !== null) {
					if (previous_untracked_writes === null) {
						previous_untracked_writes = untracked_writes;
					} else {
						previous_untracked_writes.push(.../** @type {Source[]} */ (untracked_writes));
					}
				}
			}

			if ((reaction.f & ERROR_VALUE) !== 0) {
				reaction.f ^= ERROR_VALUE;
			}

			return result;
		} catch (error) {
			return handle_error(error);
		} finally {
			reaction.f ^= REACTION_IS_UPDATING;
			new_deps = previous_deps;
			skipped_deps = previous_skipped_deps;
			untracked_writes = previous_untracked_writes;
			active_reaction = previous_reaction;
			skip_reaction = previous_skip_reaction;
			current_sources = previous_sources;
			set_component_context(previous_component_context);
			untracking = previous_untracking;
			update_version = previous_update_version;
		}
	}

	/**
	 * @template V
	 * @param {Reaction} signal
	 * @param {Value<V>} dependency
	 * @returns {void}
	 */
	function remove_reaction(signal, dependency) {
		let reactions = dependency.reactions;
		if (reactions !== null) {
			var index = index_of.call(reactions, signal);
			if (index !== -1) {
				var new_length = reactions.length - 1;
				if (new_length === 0) {
					reactions = dependency.reactions = null;
				} else {
					// Swap with last element and then remove.
					reactions[index] = reactions[new_length];
					reactions.pop();
				}
			}
		}

		// If the derived has no reactions, then we can disconnect it from the graph,
		// allowing it to either reconnect in the future, or be GC'd by the VM.
		if (
			reactions === null &&
			(dependency.f & DERIVED) !== 0 &&
			// Destroying a child effect while updating a parent effect can cause a dependency to appear
			// to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
			// allows us to skip the expensive work of disconnecting and immediately reconnecting it
			(new_deps === null || !new_deps.includes(dependency))
		) {
			set_signal_status(dependency, MAYBE_DIRTY);
			// If we are working with a derived that is owned by an effect, then mark it as being
			// disconnected.
			if ((dependency.f & (UNOWNED | DISCONNECTED)) === 0) {
				dependency.f ^= DISCONNECTED;
			}
			// Disconnect any reactions owned by this reaction
			destroy_derived_effects(/** @type {Derived} **/ (dependency));
			remove_reactions(/** @type {Derived} **/ (dependency), 0);
		}
	}

	/**
	 * @param {Reaction} signal
	 * @param {number} start_index
	 * @returns {void}
	 */
	function remove_reactions(signal, start_index) {
		var dependencies = signal.deps;
		if (dependencies === null) return;

		for (var i = start_index; i < dependencies.length; i++) {
			remove_reaction(signal, dependencies[i]);
		}
	}

	/**
	 * @param {Effect} effect
	 * @returns {void}
	 */
	function update_effect(effect) {
		var flags = effect.f;

		if ((flags & DESTROYED) !== 0) {
			return;
		}

		set_signal_status(effect, CLEAN);

		var previous_effect = active_effect;
		var was_updating_effect = is_updating_effect;

		active_effect = effect;
		is_updating_effect = true;

		if (DEV) {
			var previous_component_fn = dev_current_component_function;
			set_dev_current_component_function(effect.component_function);
			var previous_stack = /** @type {any} */ (dev_stack);
			// only block effects have a dev stack, keep the current one otherwise
			set_dev_stack(effect.dev_stack ?? dev_stack);
		}

		try {
			if ((flags & BLOCK_EFFECT) !== 0) {
				destroy_block_effect_children(effect);
			} else {
				destroy_effect_children(effect);
			}

			execute_effect_teardown(effect);
			var teardown = update_reaction(effect);
			effect.teardown = typeof teardown === 'function' ? teardown : null;
			effect.wv = write_version;

			// In DEV, increment versions of any sources that were written to during the effect,
			// so that they are correctly marked as dirty when the effect re-runs
			if (DEV && tracing_mode_flag && (effect.f & DIRTY) !== 0 && effect.deps !== null) {
				for (var dep of effect.deps) {
					if (dep.set_during_effect) {
						dep.wv = increment_write_version();
						dep.set_during_effect = false;
					}
				}
			}
		} finally {
			is_updating_effect = was_updating_effect;
			active_effect = previous_effect;

			if (DEV) {
				set_dev_current_component_function(previous_component_fn);
				set_dev_stack(previous_stack);
			}
		}
	}

	/**
	 * Returns a promise that resolves once any pending state changes have been applied.
	 * @returns {Promise<void>}
	 */
	async function tick() {

		await Promise.resolve();

		// By calling flushSync we guarantee that any pending state changes are applied after one tick.
		// TODO look into whether we can make flushing subsequent updates synchronously in the future.
		flushSync();
	}

	/**
	 * @template V
	 * @param {Value<V>} signal
	 * @returns {V}
	 */
	function get$1(signal) {
		var flags = signal.f;
		var is_derived = (flags & DERIVED) !== 0;

		captured_signals?.add(signal);

		// Register the dependency on the current reaction signal.
		if (active_reaction !== null && !untracking) {
			// if we're in a derived that is being read inside an _async_ derived,
			// it's possible that the effect was already destroyed. In this case,
			// we don't add the dependency, because that would create a memory leak
			var destroyed = active_effect !== null && (active_effect.f & DESTROYED) !== 0;

			if (!destroyed && !current_sources?.includes(signal)) {
				var deps = active_reaction.deps;

				if ((active_reaction.f & REACTION_IS_UPDATING) !== 0) {
					// we're in the effect init/update cycle
					if (signal.rv < read_version) {
						signal.rv = read_version;

						// If the signal is accessing the same dependencies in the same
						// order as it did last time, increment `skipped_deps`
						// rather than updating `new_deps`, which creates GC cost
						if (new_deps === null && deps !== null && deps[skipped_deps] === signal) {
							skipped_deps++;
						} else if (new_deps === null) {
							new_deps = [signal];
						} else if (!skip_reaction || !new_deps.includes(signal)) {
							// Normally we can push duplicated dependencies to `new_deps`, but if we're inside
							// an unowned derived because skip_reaction is true, then we need to ensure that
							// we don't have duplicates
							new_deps.push(signal);
						}
					}
				} else {
					// we're adding a dependency outside the init/update cycle
					// (i.e. after an `await`)
					(active_reaction.deps ??= []).push(signal);

					var reactions = signal.reactions;

					if (reactions === null) {
						signal.reactions = [active_reaction];
					} else if (!reactions.includes(active_reaction)) {
						reactions.push(active_reaction);
					}
				}
			}
		} else if (
			is_derived &&
			/** @type {Derived} */ (signal).deps === null &&
			/** @type {Derived} */ (signal).effects === null
		) {
			var derived = /** @type {Derived} */ (signal);
			var parent = derived.parent;

			if (parent !== null && (parent.f & UNOWNED) === 0) {
				// If the derived is owned by another derived then mark it as unowned
				// as the derived value might have been referenced in a different context
				// since and thus its parent might not be its true owner anymore
				derived.f ^= UNOWNED;
			}
		}

		if (DEV) {
			if (current_async_effect) {
				var tracking = (current_async_effect.f & REACTION_IS_UPDATING) !== 0;
				var was_read = current_async_effect.deps?.includes(signal);

				if (!tracking && !untracking && !was_read) {
					await_reactivity_loss(/** @type {string} */ (signal.label));

					var trace = get_stack('TracedAt');
					// eslint-disable-next-line no-console
					if (trace) console.warn(trace);
				}
			}

			recent_async_deriveds.delete(signal);
		}

		if (is_destroying_effect) {
			if (old_values.has(signal)) {
				return old_values.get(signal);
			}

			if (is_derived) {
				derived = /** @type {Derived} */ (signal);

				var value = derived.v;

				// if the derived is dirty and has reactions, or depends on the values that just changed, re-execute
				// (a derived can be maybe_dirty due to the effect destroy removing its last reaction)
				if (
					((derived.f & CLEAN) === 0 && derived.reactions !== null) ||
					depends_on_old_values(derived)
				) {
					value = execute_derived(derived);
				}

				old_values.set(derived, value);

				return value;
			}
		} else if (is_derived) {
			derived = /** @type {Derived} */ (signal);

			if (batch_deriveds?.has(derived)) {
				return batch_deriveds.get(derived);
			}

			if (is_dirty(derived)) {
				update_derived(derived);
			}
		}

		if ((signal.f & ERROR_VALUE) !== 0) {
			throw signal.v;
		}

		return signal.v;
	}

	/** @param {Derived} derived */
	function depends_on_old_values(derived) {
		if (derived.v === UNINITIALIZED) return true; // we don't know, so assume the worst
		if (derived.deps === null) return false;

		for (const dep of derived.deps) {
			if (old_values.has(dep)) {
				return true;
			}

			if ((dep.f & DERIVED) !== 0 && depends_on_old_values(/** @type {Derived} */ (dep))) {
				return true;
			}
		}

		return false;
	}

	/**
	 * When used inside a [`$derived`](https://svelte.dev/docs/svelte/$derived) or [`$effect`](https://svelte.dev/docs/svelte/$effect),
	 * any state read inside `fn` will not be treated as a dependency.
	 *
	 * ```ts
	 * $effect(() => {
	 *   // this will run when `data` changes, but not when `time` changes
	 *   save(data, {
	 *     timestamp: untrack(() => time)
	 *   });
	 * });
	 * ```
	 * @template T
	 * @param {() => T} fn
	 * @returns {T}
	 */
	function untrack(fn) {
		var previous_untracking = untracking;
		try {
			untracking = true;
			return fn();
		} finally {
			untracking = previous_untracking;
		}
	}

	const STATUS_MASK = ~(DIRTY | MAYBE_DIRTY | CLEAN);

	/**
	 * @param {Signal} signal
	 * @param {number} status
	 * @returns {void}
	 */
	function set_signal_status(signal, status) {
		signal.f = (signal.f & STATUS_MASK) | status;
	}

	/**
	 * Possibly traverse an object and read all its properties so that they're all reactive in case this is `$state`.
	 * Does only check first level of an object for performance reasons (heuristic should be good for 99% of all cases).
	 * @param {any} value
	 * @returns {void}
	 */
	function deep_read_state(value) {
		if (typeof value !== 'object' || !value || value instanceof EventTarget) {
			return;
		}

		if (STATE_SYMBOL in value) {
			deep_read(value);
		} else if (!Array.isArray(value)) {
			for (let key in value) {
				const prop = value[key];
				if (typeof prop === 'object' && prop && STATE_SYMBOL in prop) {
					deep_read(prop);
				}
			}
		}
	}

	/**
	 * Deeply traverse an object and read all its properties
	 * so that they're all reactive in case this is `$state`
	 * @param {any} value
	 * @param {Set<any>} visited
	 * @returns {void}
	 */
	function deep_read(value, visited = new Set()) {
		if (
			typeof value === 'object' &&
			value !== null &&
			// We don't want to traverse DOM elements
			!(value instanceof EventTarget) &&
			!visited.has(value)
		) {
			visited.add(value);
			// When working with a possible SvelteDate, this
			// will ensure we capture changes to it.
			if (value instanceof Date) {
				value.getTime();
			}
			for (let key in value) {
				try {
					deep_read(value[key], visited);
				} catch (e) {
					// continue
				}
			}
			const proto = get_prototype_of(value);
			if (
				proto !== Object.prototype &&
				proto !== Array.prototype &&
				proto !== Map.prototype &&
				proto !== Set.prototype &&
				proto !== Date.prototype
			) {
				const descriptors = get_descriptors(proto);
				for (let key in descriptors) {
					const get = descriptors[key].get;
					if (get) {
						try {
							get.call(value);
						} catch (e) {
							// continue
						}
					}
				}
			}
		}
	}

	/**
	 * @param {string} event_name
	 * @param {EventTarget} dom
	 * @param {EventListener} [handler]
	 * @param {AddEventListenerOptions} [options]
	 */
	function create_event(event_name, dom, handler, options = {}) {
		/**
		 * @this {EventTarget}
		 */
		function target_handler(/** @type {Event} */ event) {
			if (!options.capture) {
				// Only call in the bubble phase, else delegated events would be called before the capturing events
				handle_event_propagation.call(dom, event);
			}
			if (!event.cancelBubble) {
				return without_reactive_context(() => {
					return handler?.call(this, event);
				});
			}
		}

		// Chrome has a bug where pointer events don't work when attached to a DOM element that has been cloned
		// with cloneNode() and the DOM element is disconnected from the document. To ensure the event works, we
		// defer the attachment till after it's been appended to the document. TODO: remove this once Chrome fixes
		// this bug. The same applies to wheel events and touch events.
		if (
			event_name.startsWith('pointer') ||
			event_name.startsWith('touch') ||
			event_name === 'wheel'
		) {
			queue_micro_task(() => {
				dom.addEventListener(event_name, target_handler, options);
			});
		} else {
			dom.addEventListener(event_name, target_handler, options);
		}

		return target_handler;
	}

	/**
	 * @param {string} event_name
	 * @param {Element} dom
	 * @param {EventListener} [handler]
	 * @param {boolean} [capture]
	 * @param {boolean} [passive]
	 * @returns {void}
	 */
	function event(event_name, dom, handler, capture, passive) {
		var options = { capture, passive };
		var target_handler = create_event(event_name, dom, handler, options);

		if (
			dom === document.body ||
			// @ts-ignore
			dom === window ||
			// @ts-ignore
			dom === document ||
			// Firefox has quirky behavior, it can happen that we still get "canplay" events when the element is already removed
			dom instanceof HTMLMediaElement
		) {
			teardown(() => {
				dom.removeEventListener(event_name, target_handler, options);
			});
		}
	}

	// used to store the reference to the currently propagated event
	// to prevent garbage collection between microtasks in Firefox
	// If the event object is GCed too early, the expando __root property
	// set on the event object is lost, causing the event delegation
	// to process the event twice
	let last_propagated_event = null;

	/**
	 * @this {EventTarget}
	 * @param {Event} event
	 * @returns {void}
	 */
	function handle_event_propagation(event) {
		var handler_element = this;
		var owner_document = /** @type {Node} */ (handler_element).ownerDocument;
		var event_name = event.type;
		var path = event.composedPath?.() || [];
		var current_target = /** @type {null | Element} */ (path[0] || event.target);

		last_propagated_event = event;

		// composedPath contains list of nodes the event has propagated through.
		// We check __root to skip all nodes below it in case this is a
		// parent of the __root node, which indicates that there's nested
		// mounted apps. In this case we don't want to trigger events multiple times.
		var path_idx = 0;

		// the `last_propagated_event === event` check is redundant, but
		// without it the variable will be DCE'd and things will
		// fail mysteriously in Firefox
		// @ts-expect-error is added below
		var handled_at = last_propagated_event === event && event.__root;

		if (handled_at) {
			var at_idx = path.indexOf(handled_at);
			if (
				at_idx !== -1 &&
				(handler_element === document || handler_element === /** @type {any} */ (window))
			) {
				// This is the fallback document listener or a window listener, but the event was already handled
				// -> ignore, but set handle_at to document/window so that we're resetting the event
				// chain in case someone manually dispatches the same event object again.
				// @ts-expect-error
				event.__root = handler_element;
				return;
			}

			// We're deliberately not skipping if the index is higher, because
			// someone could create an event programmatically and emit it multiple times,
			// in which case we want to handle the whole propagation chain properly each time.
			// (this will only be a false negative if the event is dispatched multiple times and
			// the fallback document listener isn't reached in between, but that's super rare)
			var handler_idx = path.indexOf(handler_element);
			if (handler_idx === -1) {
				// handle_idx can theoretically be -1 (happened in some JSDOM testing scenarios with an event listener on the window object)
				// so guard against that, too, and assume that everything was handled at this point.
				return;
			}

			if (at_idx <= handler_idx) {
				path_idx = at_idx;
			}
		}

		current_target = /** @type {Element} */ (path[path_idx] || event.target);
		// there can only be one delegated event per element, and we either already handled the current target,
		// or this is the very first target in the chain which has a non-delegated listener, in which case it's safe
		// to handle a possible delegated event on it later (through the root delegation listener for example).
		if (current_target === handler_element) return;

		// Proxy currentTarget to correct target
		define_property(event, 'currentTarget', {
			configurable: true,
			get() {
				return current_target || owner_document;
			}
		});

		// This started because of Chromium issue https://chromestatus.com/feature/5128696823545856,
		// where removal or moving of of the DOM can cause sync `blur` events to fire, which can cause logic
		// to run inside the current `active_reaction`, which isn't what we want at all. However, on reflection,
		// it's probably best that all event handled by Svelte have this behaviour, as we don't really want
		// an event handler to run in the context of another reaction or effect.
		var previous_reaction = active_reaction;
		var previous_effect = active_effect;
		set_active_reaction(null);
		set_active_effect(null);

		try {
			/**
			 * @type {unknown}
			 */
			var throw_error;
			/**
			 * @type {unknown[]}
			 */
			var other_errors = [];

			while (current_target !== null) {
				/** @type {null | Element} */
				var parent_element =
					current_target.assignedSlot ||
					current_target.parentNode ||
					/** @type {any} */ (current_target).host ||
					null;

				try {
					// @ts-expect-error
					var delegated = current_target['__' + event_name];

					if (
						delegated != null &&
						(!(/** @type {any} */ (current_target).disabled) ||
							// DOM could've been updated already by the time this is reached, so we check this as well
							// -> the target could not have been disabled because it emits the event in the first place
							event.target === current_target)
					) {
						if (is_array(delegated)) {
							var [fn, ...data] = delegated;
							fn.apply(current_target, [event, ...data]);
						} else {
							delegated.call(current_target, event);
						}
					}
				} catch (error) {
					if (throw_error) {
						other_errors.push(error);
					} else {
						throw_error = error;
					}
				}
				if (event.cancelBubble || parent_element === handler_element || parent_element === null) {
					break;
				}
				current_target = parent_element;
			}

			if (throw_error) {
				for (let error of other_errors) {
					// Throw the rest of the errors, one-by-one on a microtask
					queueMicrotask(() => {
						throw error;
					});
				}
				throw throw_error;
			}
		} finally {
			// @ts-expect-error is used above
			event.__root = handler_element;
			// @ts-ignore remove proxy on currentTarget
			delete event.currentTarget;
			set_active_reaction(previous_reaction);
			set_active_effect(previous_effect);
		}
	}

	/**
	 * In dev, warn if an event handler is not a function, as it means the
	 * user probably called the handler or forgot to add a `() =>`
	 * @param {() => (event: Event, ...args: any) => void} thunk
	 * @param {EventTarget} element
	 * @param {[Event, ...any]} args
	 * @param {any} component
	 * @param {[number, number]} [loc]
	 * @param {boolean} [remove_parens]
	 */
	function apply(
		thunk,
		element,
		args,
		component,
		loc,
		has_side_effects = false,
		remove_parens = false
	) {
		let handler;
		let error;

		try {
			handler = thunk();
		} catch (e) {
			error = e;
		}

		if (typeof handler !== 'function' && (has_side_effects || handler != null || error)) {
			const filename = component?.[FILENAME];
			const location = loc ? ` at ${filename}:${loc[0]}:${loc[1]}` : ` in ${filename}`;
			const phase = args[0]?.eventPhase < Event.BUBBLING_PHASE ? 'capture' : '';
			const event_name = args[0]?.type + phase;
			const description = `\`${event_name}\` handler${location}`;
			const suggestion = remove_parens ? 'remove the trailing `()`' : 'add a leading `() =>`';

			event_handler_invalid(description, suggestion);

			if (error) {
				throw error;
			}
		}
		handler?.apply(element, args);
	}

	/** @param {string} html */
	function create_fragment_from_html(html) {
		var elem = document.createElement('template');
		elem.innerHTML = html.replaceAll('<!>', '<!---->'); // XHTML compliance
		return elem.content;
	}

	/** @import { Effect, TemplateNode } from '#client' */

	/**
	 * @param {TemplateNode} start
	 * @param {TemplateNode | null} end
	 */
	function assign_nodes(start, end) {
		var effect = /** @type {Effect} */ (active_effect);
		if (effect.nodes_start === null) {
			effect.nodes_start = start;
			effect.nodes_end = end;
		}
	}

	/**
	 * @param {string} content
	 * @param {number} flags
	 * @returns {() => Node | Node[]}
	 */
	/*#__NO_SIDE_EFFECTS__*/
	function from_html(content, flags) {
		var is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;
		var use_import_node = (flags & TEMPLATE_USE_IMPORT_NODE) !== 0;

		/** @type {Node} */
		var node;

		/**
		 * Whether or not the first item is a text/element node. If not, we need to
		 * create an additional comment node to act as `effect.nodes.start`
		 */
		var has_start = !content.startsWith('<!>');

		return () => {

			if (node === undefined) {
				node = create_fragment_from_html(has_start ? content : '<!>' + content);
				if (!is_fragment) node = /** @type {Node} */ (get_first_child(node));
			}

			var clone = /** @type {TemplateNode} */ (
				use_import_node || is_firefox ? document.importNode(node, true) : node.cloneNode(true)
			);

			if (is_fragment) {
				var start = /** @type {TemplateNode} */ (get_first_child(clone));
				var end = /** @type {TemplateNode} */ (clone.lastChild);

				assign_nodes(start, end);
			} else {
				assign_nodes(clone, clone);
			}

			return clone;
		};
	}

	/**
	 * @returns {TemplateNode | DocumentFragment}
	 */
	function comment() {

		var frag = document.createDocumentFragment();
		var start = document.createComment('');
		var anchor = create_text();
		frag.append(start, anchor);

		assign_nodes(start, anchor);

		return frag;
	}

	/**
	 * Assign the created (or in hydration mode, traversed) dom elements to the current block
	 * and insert the elements into the dom (in client mode).
	 * @param {Text | Comment | Element} anchor
	 * @param {DocumentFragment | Element} dom
	 */
	function append(anchor, dom) {

		if (anchor === null) {
			// edge case — void `<svelte:element>` with content
			return;
		}

		anchor.before(/** @type {Node} */ (dom));
	}

	/** @import { ComponentContext, Effect, TemplateNode } from '#client' */

	/**
	 * @param {Element} text
	 * @param {string} value
	 * @returns {void}
	 */
	function set_text(text, value) {
		// For objects, we apply string coercion (which might make things like $state array references in the template reactive) before diffing
		var str = value == null ? '' : typeof value === 'object' ? value + '' : value;
		// @ts-expect-error
		if (str !== (text.__t ??= text.nodeValue)) {
			// @ts-expect-error
			text.__t = str;
			text.nodeValue = str + '';
		}
	}

	/**
	 * @param {any} store
	 * @param {string} name
	 */
	function validate_store(store, name) {
		if (store != null && typeof store.subscribe !== 'function') {
			store_invalid_shape(name);
		}
	}

	/** @import { ComponentContext, ComponentContextLegacy } from '#client' */

	if (DEV) {
		/**
		 * @param {string} rune
		 */
		function throw_rune_error(rune) {
			if (!(rune in globalThis)) {
				// TODO if people start adjusting the "this can contain runes" config through v-p-s more, adjust this message
				/** @type {any} */
				let value; // let's hope noone modifies this global, but belts and braces
				Object.defineProperty(globalThis, rune, {
					configurable: true,
					// eslint-disable-next-line getter-return
					get: () => {
						if (value !== undefined) {
							return value;
						}

						rune_outside_svelte(rune);
					},
					set: (v) => {
						value = v;
					}
				});
			}
		}

		throw_rune_error('$state');
		throw_rune_error('$effect');
		throw_rune_error('$derived');
		throw_rune_error('$inspect');
		throw_rune_error('$props');
		throw_rune_error('$bindable');
	}

	/** @import { SourceLocation } from '#client' */

	/**
	 * @param {any} fn
	 * @param {string} filename
	 * @param {SourceLocation[]} locations
	 * @returns {any}
	 */
	function add_locations(fn, filename, locations) {
		return (/** @type {any[]} */ ...args) => {
			const dom = fn(...args);

			var node = dom.nodeType === DOCUMENT_FRAGMENT_NODE ? dom.firstChild : dom;
			assign_locations(node, filename, locations);

			return dom;
		};
	}

	/**
	 * @param {Element} element
	 * @param {string} filename
	 * @param {SourceLocation} location
	 */
	function assign_location(element, filename, location) {
		// @ts-expect-error
		element.__svelte_meta = {
			parent: dev_stack,
			loc: { file: filename, line: location[0], column: location[1] }
		};

		if (location[2]) {
			assign_locations(element.firstChild, filename, location[2]);
		}
	}

	/**
	 * @param {Node | null} node
	 * @param {string} filename
	 * @param {SourceLocation[]} locations
	 */
	function assign_locations(node, filename, locations) {
		var i = 0;

		while (node && i < locations.length) {

			if (node.nodeType === ELEMENT_NODE) {
				assign_location(/** @type {Element} */ (node), filename, locations[i++]);
			}

			node = node.nextSibling;
		}
	}

	/** @param {Function & { [FILENAME]: string }} target */
	function check_target(target) {
		if (target) {
			component_api_invalid_new(target[FILENAME] ?? 'a component', target.name);
		}
	}

	function legacy_api() {
		const component = component_context?.function;

		/** @param {string} method */
		function error(method) {
			component_api_changed(method, component[FILENAME]);
		}

		return {
			$destroy: () => error('$destroy()'),
			$on: () => error('$on(...)'),
			$set: () => error('$set(...)')
		};
	}

	/** @import { Effect, TemplateNode } from '#client' */

	// TODO reinstate https://github.com/sveltejs/svelte/pull/15250

	/**
	 * @param {TemplateNode} node
	 * @param {(branch: (fn: (anchor: Node) => void, flag?: boolean) => void) => void} fn
	 * @param {boolean} [elseif] True if this is an `{:else if ...}` block rather than an `{#if ...}`, as that affects which transitions are considered 'local'
	 * @returns {void}
	 */
	function if_block(node, fn, elseif = false) {

		var anchor = node;

		/** @type {Effect | null} */
		var consequent_effect = null;

		/** @type {Effect | null} */
		var alternate_effect = null;

		/** @type {typeof UNINITIALIZED | boolean | null} */
		var condition = UNINITIALIZED;

		var flags = elseif ? EFFECT_TRANSPARENT : 0;

		var has_branch = false;

		const set_branch = (/** @type {(anchor: Node) => void} */ fn, flag = true) => {
			has_branch = true;
			update_branch(flag, fn);
		};

		/** @type {DocumentFragment | null} */
		var offscreen_fragment = null;

		function commit() {
			if (offscreen_fragment !== null) {
				// remove the anchor
				/** @type {Text} */ (offscreen_fragment.lastChild).remove();

				anchor.before(offscreen_fragment);
				offscreen_fragment = null;
			}

			var active = condition ? consequent_effect : alternate_effect;
			var inactive = condition ? alternate_effect : consequent_effect;

			if (active) {
				resume_effect(active);
			}

			if (inactive) {
				pause_effect(inactive, () => {
					if (condition) {
						alternate_effect = null;
					} else {
						consequent_effect = null;
					}
				});
			}
		}

		const update_branch = (
			/** @type {boolean | null} */ new_condition,
			/** @type {null | ((anchor: Node) => void)} */ fn
		) => {
			if (condition === (condition = new_condition)) return;

			var defer = should_defer_append();
			var target = anchor;

			if (defer) {
				offscreen_fragment = document.createDocumentFragment();
				offscreen_fragment.append((target = create_text()));
			}

			if (condition) {
				consequent_effect ??= fn && branch(() => fn(target));
			} else {
				alternate_effect ??= fn && branch(() => fn(target));
			}

			if (defer) {
				var batch = /** @type {Batch} */ (current_batch);

				var active = condition ? consequent_effect : alternate_effect;
				var inactive = condition ? alternate_effect : consequent_effect;

				if (active) batch.skipped_effects.delete(active);
				if (inactive) batch.skipped_effects.add(inactive);

				batch.add_callback(commit);
			} else {
				commit();
			}
		};

		block(() => {
			has_branch = false;
			fn(set_branch);
			if (!has_branch) {
				update_branch(null, null);
			}
		}, flags);
	}

	/** @import { EachItem, EachState, Effect, MaybeSource, Source, TemplateNode, TransitionManager, Value } from '#client' */

	/**
	 * @param {any} _
	 * @param {number} i
	 */
	function index(_, i) {
		return i;
	}

	/**
	 * Pause multiple effects simultaneously, and coordinate their
	 * subsequent destruction. Used in each blocks
	 * @param {EachState} state
	 * @param {EachItem[]} items
	 * @param {null | Node} controlled_anchor
	 */
	function pause_effects(state, items, controlled_anchor) {
		var items_map = state.items;

		/** @type {TransitionManager[]} */
		var transitions = [];
		var length = items.length;

		for (var i = 0; i < length; i++) {
			pause_children(items[i].e, transitions, true);
		}

		var is_controlled = length > 0 && transitions.length === 0 && controlled_anchor !== null;
		// If we have a controlled anchor, it means that the each block is inside a single
		// DOM element, so we can apply a fast-path for clearing the contents of the element.
		if (is_controlled) {
			var parent_node = /** @type {Element} */ (
				/** @type {Element} */ (controlled_anchor).parentNode
			);
			clear_text_content(parent_node);
			parent_node.append(/** @type {Element} */ (controlled_anchor));
			items_map.clear();
			link(state, items[0].prev, items[length - 1].next);
		}

		run_out_transitions(transitions, () => {
			for (var i = 0; i < length; i++) {
				var item = items[i];
				if (!is_controlled) {
					items_map.delete(item.k);
					link(state, item.prev, item.next);
				}
				destroy_effect(item.e, !is_controlled);
			}
		});
	}

	/**
	 * @template V
	 * @param {Element | Comment} node The next sibling node, or the parent node if this is a 'controlled' block
	 * @param {number} flags
	 * @param {() => V[]} get_collection
	 * @param {(value: V, index: number) => any} get_key
	 * @param {(anchor: Node, item: MaybeSource<V>, index: MaybeSource<number>) => void} render_fn
	 * @param {null | ((anchor: Node) => void)} fallback_fn
	 * @returns {void}
	 */
	function each(node, flags, get_collection, get_key, render_fn, fallback_fn = null) {
		var anchor = node;

		/** @type {EachState} */
		var state = { flags, items: new Map(), first: null };

		var is_controlled = (flags & EACH_IS_CONTROLLED) !== 0;

		if (is_controlled) {
			var parent_node = /** @type {Element} */ (node);

			anchor = parent_node.appendChild(create_text());
		}

		/** @type {Effect | null} */
		var fallback = null;

		var was_empty = false;

		/** @type {Map<any, EachItem>} */
		var offscreen_items = new Map();

		// TODO: ideally we could use derived for runes mode but because of the ability
		// to use a store which can be mutated, we can't do that here as mutating a store
		// will still result in the collection array being the same from the store
		var each_array = derived_safe_equal(() => {
			var collection = get_collection();

			return is_array(collection) ? collection : collection == null ? [] : array_from(collection);
		});

		/** @type {V[]} */
		var array;

		/** @type {Effect} */
		var each_effect;

		function commit() {
			reconcile(
				each_effect,
				array,
				state,
				offscreen_items,
				anchor,
				render_fn,
				flags,
				get_key,
				get_collection
			);

			if (fallback_fn !== null) {
				if (array.length === 0) {
					if (fallback) {
						resume_effect(fallback);
					} else {
						fallback = branch(() => fallback_fn(anchor));
					}
				} else if (fallback !== null) {
					pause_effect(fallback, () => {
						fallback = null;
					});
				}
			}
		}

		block(() => {
			// store a reference to the effect so that we can update the start/end nodes in reconciliation
			each_effect ??= /** @type {Effect} */ (active_effect);

			array = /** @type {V[]} */ (get$1(each_array));
			var length = array.length;

			if (was_empty && length === 0) {
				// ignore updates if the array is empty,
				// and it already was empty on previous run
				return;
			}
			was_empty = length === 0;

			// this is separate to the previous block because `hydrating` might change
			var item, i, value, key; 

			{
				if (should_defer_append()) {
					var keys = new Set();
					var batch = /** @type {Batch} */ (current_batch);

					for (i = 0; i < length; i += 1) {
						value = array[i];
						key = get_key(value, i);

						var existing = state.items.get(key) ?? offscreen_items.get(key);

						if (existing) {
							// update before reconciliation, to trigger any async updates
							if ((flags & (EACH_ITEM_REACTIVE | EACH_INDEX_REACTIVE)) !== 0) {
								update_item(existing, value, i, flags);
							}
						} else {
							item = create_item(
								null,
								state,
								null,
								null,
								value,
								key,
								i,
								render_fn,
								flags,
								get_collection,
								true
							);

							offscreen_items.set(key, item);
						}

						keys.add(key);
					}

					for (const [key, item] of state.items) {
						if (!keys.has(key)) {
							batch.skipped_effects.add(item.e);
						}
					}

					batch.add_callback(commit);
				} else {
					commit();
				}
			}

			// When we mount the each block for the first time, the collection won't be
			// connected to this effect as the effect hasn't finished running yet and its deps
			// won't be assigned. However, it's possible that when reconciling the each block
			// that a mutation occurred and it's made the collection MAYBE_DIRTY, so reading the
			// collection again can provide consistency to the reactive graph again as the deriveds
			// will now be `CLEAN`.
			get$1(each_array);
		});
	}

	/**
	 * Add, remove, or reorder items output by an each block as its input changes
	 * @template V
	 * @param {Effect} each_effect
	 * @param {Array<V>} array
	 * @param {EachState} state
	 * @param {Map<any, EachItem>} offscreen_items
	 * @param {Element | Comment | Text} anchor
	 * @param {(anchor: Node, item: MaybeSource<V>, index: number | Source<number>, collection: () => V[]) => void} render_fn
	 * @param {number} flags
	 * @param {(value: V, index: number) => any} get_key
	 * @param {() => V[]} get_collection
	 * @returns {void}
	 */
	function reconcile(
		each_effect,
		array,
		state,
		offscreen_items,
		anchor,
		render_fn,
		flags,
		get_key,
		get_collection
	) {
		var is_animated = (flags & EACH_IS_ANIMATED) !== 0;
		var should_update = (flags & (EACH_ITEM_REACTIVE | EACH_INDEX_REACTIVE)) !== 0;

		var length = array.length;
		var items = state.items;
		var first = state.first;
		var current = first;

		/** @type {undefined | Set<EachItem>} */
		var seen;

		/** @type {EachItem | null} */
		var prev = null;

		/** @type {undefined | Set<EachItem>} */
		var to_animate;

		/** @type {EachItem[]} */
		var matched = [];

		/** @type {EachItem[]} */
		var stashed = [];

		/** @type {V} */
		var value;

		/** @type {any} */
		var key;

		/** @type {EachItem | undefined} */
		var item;

		/** @type {number} */
		var i;

		if (is_animated) {
			for (i = 0; i < length; i += 1) {
				value = array[i];
				key = get_key(value, i);
				item = items.get(key);

				if (item !== undefined) {
					item.a?.measure();
					(to_animate ??= new Set()).add(item);
				}
			}
		}

		for (i = 0; i < length; i += 1) {
			value = array[i];
			key = get_key(value, i);

			item = items.get(key);

			if (item === undefined) {
				var pending = offscreen_items.get(key);

				if (pending !== undefined) {
					offscreen_items.delete(key);
					items.set(key, pending);

					var next = prev ? prev.next : current;

					link(state, prev, pending);
					link(state, pending, next);

					move(pending, next, anchor);
					prev = pending;
				} else {
					var child_anchor = current ? /** @type {TemplateNode} */ (current.e.nodes_start) : anchor;

					prev = create_item(
						child_anchor,
						state,
						prev,
						prev === null ? state.first : prev.next,
						value,
						key,
						i,
						render_fn,
						flags,
						get_collection
					);
				}

				items.set(key, prev);

				matched = [];
				stashed = [];

				current = prev.next;
				continue;
			}

			if (should_update) {
				update_item(item, value, i, flags);
			}

			if ((item.e.f & INERT) !== 0) {
				resume_effect(item.e);
				if (is_animated) {
					item.a?.unfix();
					(to_animate ??= new Set()).delete(item);
				}
			}

			if (item !== current) {
				if (seen !== undefined && seen.has(item)) {
					if (matched.length < stashed.length) {
						// more efficient to move later items to the front
						var start = stashed[0];
						var j;

						prev = start.prev;

						var a = matched[0];
						var b = matched[matched.length - 1];

						for (j = 0; j < matched.length; j += 1) {
							move(matched[j], start, anchor);
						}

						for (j = 0; j < stashed.length; j += 1) {
							seen.delete(stashed[j]);
						}

						link(state, a.prev, b.next);
						link(state, prev, a);
						link(state, b, start);

						current = start;
						prev = b;
						i -= 1;

						matched = [];
						stashed = [];
					} else {
						// more efficient to move earlier items to the back
						seen.delete(item);
						move(item, current, anchor);

						link(state, item.prev, item.next);
						link(state, item, prev === null ? state.first : prev.next);
						link(state, prev, item);

						prev = item;
					}

					continue;
				}

				matched = [];
				stashed = [];

				while (current !== null && current.k !== key) {
					// If the each block isn't inert and an item has an effect that is already inert,
					// skip over adding it to our seen Set as the item is already being handled
					if ((current.e.f & INERT) === 0) {
						(seen ??= new Set()).add(current);
					}
					stashed.push(current);
					current = current.next;
				}

				if (current === null) {
					continue;
				}

				item = current;
			}

			matched.push(item);
			prev = item;
			current = item.next;
		}

		if (current !== null || seen !== undefined) {
			var to_destroy = seen === undefined ? [] : array_from(seen);

			while (current !== null) {
				// If the each block isn't inert, then inert effects are currently outroing and will be removed once the transition is finished
				if ((current.e.f & INERT) === 0) {
					to_destroy.push(current);
				}
				current = current.next;
			}

			var destroy_length = to_destroy.length;

			if (destroy_length > 0) {
				var controlled_anchor = (flags & EACH_IS_CONTROLLED) !== 0 && length === 0 ? anchor : null;

				if (is_animated) {
					for (i = 0; i < destroy_length; i += 1) {
						to_destroy[i].a?.measure();
					}

					for (i = 0; i < destroy_length; i += 1) {
						to_destroy[i].a?.fix();
					}
				}

				pause_effects(state, to_destroy, controlled_anchor);
			}
		}

		if (is_animated) {
			queue_micro_task(() => {
				if (to_animate === undefined) return;
				for (item of to_animate) {
					item.a?.apply();
				}
			});
		}

		each_effect.first = state.first && state.first.e;
		each_effect.last = prev && prev.e;

		for (var unused of offscreen_items.values()) {
			destroy_effect(unused.e);
		}

		offscreen_items.clear();
	}

	/**
	 * @param {EachItem} item
	 * @param {any} value
	 * @param {number} index
	 * @param {number} type
	 * @returns {void}
	 */
	function update_item(item, value, index, type) {
		if ((type & EACH_ITEM_REACTIVE) !== 0) {
			internal_set(item.v, value);
		}

		if ((type & EACH_INDEX_REACTIVE) !== 0) {
			internal_set(/** @type {Value<number>} */ (item.i), index);
		} else {
			item.i = index;
		}
	}

	/**
	 * @template V
	 * @param {Node | null} anchor
	 * @param {EachState} state
	 * @param {EachItem | null} prev
	 * @param {EachItem | null} next
	 * @param {V} value
	 * @param {unknown} key
	 * @param {number} index
	 * @param {(anchor: Node, item: V | Source<V>, index: number | Value<number>, collection: () => V[]) => void} render_fn
	 * @param {number} flags
	 * @param {() => V[]} get_collection
	 * @param {boolean} [deferred]
	 * @returns {EachItem}
	 */
	function create_item(
		anchor,
		state,
		prev,
		next,
		value,
		key,
		index,
		render_fn,
		flags,
		get_collection,
		deferred
	) {
		var reactive = (flags & EACH_ITEM_REACTIVE) !== 0;
		var mutable = (flags & EACH_ITEM_IMMUTABLE) === 0;

		var v = reactive ? (mutable ? mutable_source(value, false, false) : source(value)) : value;
		var i = (flags & EACH_INDEX_REACTIVE) === 0 ? index : source(index);

		if (DEV && reactive) {
			// For tracing purposes, we need to link the source signal we create with the
			// collection + index so that tracing works as intended
			/** @type {Value} */ (v).trace = () => {
				var collection_index = typeof i === 'number' ? index : i.v;
				// eslint-disable-next-line @typescript-eslint/no-unused-expressions
				get_collection()[collection_index];
			};
		}

		/** @type {EachItem} */
		var item = {
			i,
			v,
			k: key,
			a: null,
			// @ts-expect-error
			e: null,
			prev,
			next
		};

		try {
			if (anchor === null) {
				var fragment = document.createDocumentFragment();
				fragment.append((anchor = create_text()));
			}

			item.e = branch(() => render_fn(/** @type {Node} */ (anchor), v, i, get_collection), hydrating);

			item.e.prev = prev && prev.e;
			item.e.next = next && next.e;

			if (prev === null) {
				if (!deferred) {
					state.first = item;
				}
			} else {
				prev.next = item;
				prev.e.next = item.e;
			}

			if (next !== null) {
				next.prev = item;
				next.e.prev = item.e;
			}

			return item;
		} finally {
		}
	}

	/**
	 * @param {EachItem} item
	 * @param {EachItem | null} next
	 * @param {Text | Element | Comment} anchor
	 */
	function move(item, next, anchor) {
		var end = item.next ? /** @type {TemplateNode} */ (item.next.e.nodes_start) : anchor;

		var dest = next ? /** @type {TemplateNode} */ (next.e.nodes_start) : anchor;
		var node = /** @type {TemplateNode} */ (item.e.nodes_start);

		while (node !== null && node !== end) {
			var next_node = /** @type {TemplateNode} */ (get_next_sibling(node));
			dest.before(node);
			node = next_node;
		}
	}

	/**
	 * @param {EachState} state
	 * @param {EachItem | null} prev
	 * @param {EachItem | null} next
	 */
	function link(state, prev, next) {
		if (prev === null) {
			state.first = next;
		} else {
			prev.next = next;
			prev.e.next = next && next.e;
		}

		if (next !== null) {
			next.prev = prev;
			next.e.prev = prev && prev.e;
		}
	}

	const whitespace = [...' \t\n\r\f\u00a0\u000b\ufeff'];

	/**
	 * @param {any} value
	 * @param {string | null} [hash]
	 * @param {Record<string, boolean>} [directives]
	 * @returns {string | null}
	 */
	function to_class(value, hash, directives) {
		var classname = value == null ? '' : '' + value;

		if (hash) {
			classname = classname ? classname + ' ' + hash : hash;
		}

		if (directives) {
			for (var key in directives) {
				if (directives[key]) {
					classname = classname ? classname + ' ' + key : key;
				} else if (classname.length) {
					var len = key.length;
					var a = 0;

					while ((a = classname.indexOf(key, a)) >= 0) {
						var b = a + len;

						if (
							(a === 0 || whitespace.includes(classname[a - 1])) &&
							(b === classname.length || whitespace.includes(classname[b]))
						) {
							classname = (a === 0 ? '' : classname.substring(0, a)) + classname.substring(b + 1);
						} else {
							a = b;
						}
					}
				}
			}
		}

		return classname === '' ? null : classname;
	}

	/**
	 * @param {Element} dom
	 * @param {boolean | number} is_html
	 * @param {string | null} value
	 * @param {string} [hash]
	 * @param {Record<string, any>} [prev_classes]
	 * @param {Record<string, any>} [next_classes]
	 * @returns {Record<string, boolean> | undefined}
	 */
	function set_class(dom, is_html, value, hash, prev_classes, next_classes) {
		// @ts-expect-error need to add __className to patched prototype
		var prev = dom.__className;

		if (
			prev !== value ||
			prev === undefined // for edge case of `class={undefined}`
		) {
			var next_class_name = to_class(value, hash, next_classes);

			{
				// Removing the attribute when the value is only an empty string causes
				// performance issues vs simply making the className an empty string. So
				// we should only remove the class if the value is nullish
				// and there no hash/directives :
				if (next_class_name == null) {
					dom.removeAttribute('class');
				} else if (is_html) {
					dom.className = next_class_name;
				} else {
					dom.setAttribute('class', next_class_name);
				}
			}

			// @ts-expect-error need to add __className to patched prototype
			dom.__className = value;
		} else if (next_classes && prev_classes !== next_classes) {
			for (var key in next_classes) {
				var is_present = !!next_classes[key];

				if (prev_classes == null || is_present !== !!prev_classes[key]) {
					dom.classList.toggle(key, is_present);
				}
			}
		}

		return next_classes;
	}

	/** @import { Batch } from '../../../reactivity/batch.js' */

	/**
	 * @param {HTMLInputElement} input
	 * @param {() => unknown} get
	 * @param {(value: unknown) => void} set
	 * @returns {void}
	 */
	function bind_value(input, get, set = get) {
		var batches = new WeakSet();

		listen_to_event_and_reset_event(input, 'input', async (is_reset) => {
			if (DEV && input.type === 'checkbox') {
				// TODO should this happen in prod too?
				bind_invalid_checkbox_value();
			}

			/** @type {any} */
			var value = is_reset ? input.defaultValue : input.value;
			value = is_numberlike_input(input) ? to_number(value) : value;
			set(value);

			if (current_batch !== null) {
				batches.add(current_batch);
			}

			// Because `{#each ...}` blocks work by updating sources inside the flush,
			// we need to wait a tick before checking to see if we should forcibly
			// update the input and reset the selection state
			await tick();

			// Respect any validation in accessors
			if (value !== (value = get())) {
				var start = input.selectionStart;
				var end = input.selectionEnd;

				// the value is coerced on assignment
				input.value = value ?? '';

				// Restore selection
				if (end !== null) {
					input.selectionStart = start;
					input.selectionEnd = Math.min(end, input.value.length);
				}
			}
		});

		if (
			// If we are hydrating and the value has since changed,
			// then use the updated value from the input instead.
			// If defaultValue is set, then value == defaultValue
			// TODO Svelte 6: remove input.value check and set to empty string?
			(untrack(get) == null && input.value)
		) {
			set(is_numberlike_input(input) ? to_number(input.value) : input.value);

			if (current_batch !== null) {
				batches.add(current_batch);
			}
		}

		render_effect(() => {
			if (DEV && input.type === 'checkbox') {
				// TODO should this happen in prod too?
				bind_invalid_checkbox_value();
			}

			var value = get();

			if (input === document.activeElement) {
				// we need both, because in non-async mode, render effects run before previous_batch is set
				var batch = /** @type {Batch} */ (previous_batch ?? current_batch);

				// Never rewrite the contents of a focused input. We can get here if, for example,
				// an update is deferred because of async work depending on the input:
				//
				// <input bind:value={query}>
				// <p>{await find(query)}</p>
				if (batches.has(batch)) {
					return;
				}
			}

			if (is_numberlike_input(input) && value === to_number(input.value)) {
				// handles 0 vs 00 case (see https://github.com/sveltejs/svelte/issues/9959)
				return;
			}

			if (input.type === 'date' && !value && !input.value) {
				// Handles the case where a temporarily invalid date is set (while typing, for example with a leading 0 for the day)
				// and prevents this state from clearing the other parts of the date input (see https://github.com/sveltejs/svelte/issues/7897)
				return;
			}

			// don't set the value of the input if it's the same to allow
			// minlength to work properly
			if (value !== input.value) {
				// @ts-expect-error the value is coerced on assignment
				input.value = value ?? '';
			}
		});
	}

	/**
	 * @param {HTMLInputElement} input
	 * @param {() => unknown} get
	 * @param {(value: unknown) => void} set
	 * @returns {void}
	 */
	function bind_checked(input, get, set = get) {
		listen_to_event_and_reset_event(input, 'change', (is_reset) => {
			var value = is_reset ? input.defaultChecked : input.checked;
			set(value);
		});

		if (
			// If we are hydrating and the value has since changed,
			// then use the update value from the input instead.
			// If defaultChecked is set, then checked == defaultChecked
			untrack(get) == null
		) {
			set(input.checked);
		}

		render_effect(() => {
			var value = get();
			input.checked = Boolean(value);
		});
	}

	/**
	 * @param {HTMLInputElement} input
	 */
	function is_numberlike_input(input) {
		var type = input.type;
		return type === 'number' || type === 'range';
	}

	/**
	 * @param {string} value
	 */
	function to_number(value) {
		return value === '' ? null : +value;
	}

	/** @import { ComponentContextLegacy } from '#client' */

	/**
	 * Legacy-mode only: Call `onMount` callbacks and set up `beforeUpdate`/`afterUpdate` effects
	 * @param {boolean} [immutable]
	 */
	function init(immutable = false) {
		const context = /** @type {ComponentContextLegacy} */ (component_context);

		const callbacks = context.l.u;
		if (!callbacks) return;

		let props = () => deep_read_state(context.s);

		if (immutable) {
			let version = 0;
			let prev = /** @type {Record<string, any>} */ ({});

			// In legacy immutable mode, before/afterUpdate only fire if the object identity of a prop changes
			const d = derived(() => {
				let changed = false;
				const props = context.s;
				for (const key in props) {
					if (props[key] !== prev[key]) {
						prev[key] = props[key];
						changed = true;
					}
				}
				if (changed) version++;
				return version;
			});

			props = () => get$1(d);
		}

		// beforeUpdate
		if (callbacks.b.length) {
			user_pre_effect(() => {
				observe_all(context, props);
				run_all(callbacks.b);
			});
		}

		// onMount (must run before afterUpdate)
		user_effect(() => {
			const fns = untrack(() => callbacks.m.map(run));
			return () => {
				for (const fn of fns) {
					if (typeof fn === 'function') {
						fn();
					}
				}
			};
		});

		// afterUpdate
		if (callbacks.a.length) {
			user_effect(() => {
				observe_all(context, props);
				run_all(callbacks.a);
			});
		}
	}

	/**
	 * Invoke the getter of all signals associated with a component
	 * so they can be registered to the effect this function is called in.
	 * @param {ComponentContextLegacy} context
	 * @param {(() => void)} props
	 */
	function observe_all(context, props) {
		if (context.l.s) {
			for (const signal of context.l.s) get$1(signal);
		}

		props();
	}

	/**
	 * @this {any}
	 * @param {Record<string, unknown>} $$props
	 * @param {Event} event
	 * @returns {void}
	 */
	function bubble_event($$props, event) {
		var events = /** @type {Record<string, Function[] | Function>} */ ($$props.$$events)?.[
			event.type
		];

		var callbacks = is_array(events) ? events.slice() : events == null ? [] : [events];

		for (var fn of callbacks) {
			// Preserve "this" context
			fn.call(this, event);
		}
	}

	/** @import { Readable } from './public' */

	/**
	 * @template T
	 * @param {Readable<T> | null | undefined} store
	 * @param {(value: T) => void} run
	 * @param {(value: T) => void} [invalidate]
	 * @returns {() => void}
	 */
	function subscribe_to_store(store, run, invalidate) {
		if (store == null) {
			// @ts-expect-error
			run(undefined);

			// @ts-expect-error
			if (invalidate) invalidate(undefined);

			return noop;
		}

		// Svelte store takes a private second argument
		// StartStopNotifier could mutate state, and we want to silence the corresponding validation error
		const unsub = untrack(() =>
			store.subscribe(
				run,
				// @ts-expect-error
				invalidate
			)
		);

		// Also support RxJS
		// @ts-expect-error TODO fix this in the types?
		return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
	}

	/** @import { Readable, StartStopNotifier, Subscriber, Unsubscriber, Updater, Writable } from '../public.js' */

	/**
	 * @type {Array<SubscribeInvalidateTuple<any> | any>}
	 */
	const subscriber_queue = [];

	/**
	 * Create a `Writable` store that allows both updating and reading by subscription.
	 *
	 * @template T
	 * @param {T} [value] initial value
	 * @param {StartStopNotifier<T>} [start]
	 * @returns {Writable<T>}
	 */
	function writable(value, start = noop) {
		/** @type {Unsubscriber | null} */
		let stop = null;

		/** @type {Set<SubscribeInvalidateTuple<T>>} */
		const subscribers = new Set();

		/**
		 * @param {T} new_value
		 * @returns {void}
		 */
		function set(new_value) {
			if (safe_not_equal(value, new_value)) {
				value = new_value;
				if (stop) {
					// store is ready
					const run_queue = !subscriber_queue.length;
					for (const subscriber of subscribers) {
						subscriber[1]();
						subscriber_queue.push(subscriber, value);
					}
					if (run_queue) {
						for (let i = 0; i < subscriber_queue.length; i += 2) {
							subscriber_queue[i][0](subscriber_queue[i + 1]);
						}
						subscriber_queue.length = 0;
					}
				}
			}
		}

		/**
		 * @param {Updater<T>} fn
		 * @returns {void}
		 */
		function update(fn) {
			set(fn(/** @type {T} */ (value)));
		}

		/**
		 * @param {Subscriber<T>} run
		 * @param {() => void} [invalidate]
		 * @returns {Unsubscriber}
		 */
		function subscribe(run, invalidate = noop) {
			/** @type {SubscribeInvalidateTuple<T>} */
			const subscriber = [run, invalidate];
			subscribers.add(subscriber);
			if (subscribers.size === 1) {
				stop = start(set, update) || noop;
			}
			run(/** @type {T} */ (value));
			return () => {
				subscribers.delete(subscriber);
				if (subscribers.size === 0 && stop) {
					stop();
					stop = null;
				}
			};
		}
		return { set, update, subscribe };
	}

	/**
	 * Get the current value from a store by subscribing and immediately unsubscribing.
	 *
	 * @template T
	 * @param {Readable<T>} store
	 * @returns {T}
	 */
	function get(store) {
		let value;
		subscribe_to_store(store, (_) => (value = _))();
		// @ts-expect-error
		return value;
	}

	/** @import { StoreReferencesContainer } from '#client' */

	/**
	 * Whether or not the prop currently being read is a store binding, as in
	 * `<Child bind:x={$y} />`. If it is, we treat the prop as mutable even in
	 * runes mode, and skip `binding_property_non_reactive` validation
	 */
	let is_store_binding = false;

	let IS_UNMOUNTED = Symbol();

	/**
	 * Gets the current value of a store. If the store isn't subscribed to yet, it will create a proxy
	 * signal that will be updated when the store is. The store references container is needed to
	 * track reassignments to stores and to track the correct component context.
	 * @template V
	 * @param {Store<V> | null | undefined} store
	 * @param {string} store_name
	 * @param {StoreReferencesContainer} stores
	 * @returns {V}
	 */
	function store_get(store, store_name, stores) {
		const entry = (stores[store_name] ??= {
			store: null,
			source: mutable_source(undefined),
			unsubscribe: noop
		});

		if (DEV) {
			entry.source.label = store_name;
		}

		// if the component that setup this is already unmounted we don't want to register a subscription
		if (entry.store !== store && !(IS_UNMOUNTED in stores)) {
			entry.unsubscribe();
			entry.store = store ?? null;

			if (store == null) {
				entry.source.v = undefined; // see synchronous callback comment below
				entry.unsubscribe = noop;
			} else {
				var is_synchronous_callback = true;

				entry.unsubscribe = subscribe_to_store(store, (v) => {
					if (is_synchronous_callback) {
						// If the first updates to the store value (possibly multiple of them) are synchronously
						// inside a derived, we will hit the `state_unsafe_mutation` error if we `set` the value
						entry.source.v = v;
					} else {
						set(entry.source, v);
					}
				});

				is_synchronous_callback = false;
			}
		}

		// if the component that setup this stores is already unmounted the source will be out of sync
		// so we just use the `get` for the stores, less performant but it avoids to create a memory leak
		// and it will keep the value consistent
		if (store && IS_UNMOUNTED in stores) {
			return get(store);
		}

		return get$1(entry.source);
	}

	/**
	 * Unsubscribes from all auto-subscribed stores on destroy
	 * @returns {[StoreReferencesContainer, ()=>void]}
	 */
	function setup_stores() {
		/** @type {StoreReferencesContainer} */
		const stores = {};

		function cleanup() {
			teardown(() => {
				for (var store_name in stores) {
					const ref = stores[store_name];
					ref.unsubscribe();
				}
				define_property(stores, IS_UNMOUNTED, {
					enumerable: false,
					value: true
				});
			});
		}

		return [stores, cleanup];
	}

	/**
	 * Returns a tuple that indicates whether `fn()` reads a prop that is a store binding.
	 * Used to prevent `binding_property_non_reactive` validation false positives and
	 * ensure that these props are treated as mutable even in runes mode
	 * @template T
	 * @param {() => T} fn
	 * @returns {[T, boolean]}
	 */
	function capture_store_binding(fn) {
		var previous_is_store_binding = is_store_binding;

		try {
			is_store_binding = false;
			return [fn(), is_store_binding];
		} finally {
			is_store_binding = previous_is_store_binding;
		}
	}

	/** @import { Effect, Source } from './types.js' */

	/**
	 * This function is responsible for synchronizing a possibly bound prop with the inner component state.
	 * It is used whenever the compiler sees that the component writes to the prop, or when it has a default prop_value.
	 * @template V
	 * @param {Record<string, unknown>} props
	 * @param {string} key
	 * @param {number} flags
	 * @param {V | (() => V)} [fallback]
	 * @returns {(() => V | ((arg: V) => V) | ((arg: V, mutation: boolean) => V))}
	 */
	function prop(props, key, flags, fallback) {
		var runes = !legacy_mode_flag || (flags & PROPS_IS_RUNES) !== 0;
		var bindable = (flags & PROPS_IS_BINDABLE) !== 0;
		var lazy = (flags & PROPS_IS_LAZY_INITIAL) !== 0;

		var fallback_value = /** @type {V} */ (fallback);
		var fallback_dirty = true;

		var get_fallback = () => {
			if (fallback_dirty) {
				fallback_dirty = false;

				fallback_value = lazy
					? untrack(/** @type {() => V} */ (fallback))
					: /** @type {V} */ (fallback);
			}

			return fallback_value;
		};

		/** @type {((v: V) => void) | undefined} */
		var setter;

		if (bindable) {
			// Can be the case when someone does `mount(Component, props)` with `let props = $state({...})`
			// or `createClassComponent(Component, props)`
			var is_entry_props = STATE_SYMBOL in props || LEGACY_PROPS in props;

			setter =
				get_descriptor(props, key)?.set ??
				(is_entry_props && key in props ? (v) => (props[key] = v) : undefined);
		}

		var initial_value;
		var is_store_sub = false;

		if (bindable) {
			[initial_value, is_store_sub] = capture_store_binding(() => /** @type {V} */ (props[key]));
		} else {
			initial_value = /** @type {V} */ (props[key]);
		}

		if (initial_value === undefined && fallback !== undefined) {
			initial_value = get_fallback();

			if (setter) {
				if (runes) props_invalid_value(key);
				setter(initial_value);
			}
		}

		/** @type {() => V} */
		var getter;

		if (runes) {
			getter = () => {
				var value = /** @type {V} */ (props[key]);
				if (value === undefined) return get_fallback();
				fallback_dirty = true;
				return value;
			};
		} else {
			getter = () => {
				var value = /** @type {V} */ (props[key]);

				if (value !== undefined) {
					// in legacy mode, we don't revert to the fallback value
					// if the prop goes from defined to undefined. The easiest
					// way to model this is to make the fallback undefined
					// as soon as the prop has a value
					fallback_value = /** @type {V} */ (undefined);
				}

				return value === undefined ? fallback_value : value;
			};
		}

		// prop is never written to — we only need a getter
		if (runes && (flags & PROPS_IS_UPDATED) === 0) {
			return getter;
		}

		// prop is written to, but the parent component had `bind:foo` which
		// means we can just call `$$props.foo = value` directly
		if (setter) {
			var legacy_parent = props.$$legacy;
			return /** @type {() => V} */ (
				function (/** @type {V} */ value, /** @type {boolean} */ mutation) {
					if (arguments.length > 0) {
						// We don't want to notify if the value was mutated and the parent is in runes mode.
						// In that case the state proxy (if it exists) should take care of the notification.
						// If the parent is not in runes mode, we need to notify on mutation, too, that the prop
						// has changed because the parent will not be able to detect the change otherwise.
						if (!runes || !mutation || legacy_parent || is_store_sub) {
							/** @type {Function} */ (setter)(mutation ? getter() : value);
						}

						return value;
					}

					return getter();
				}
			);
		}

		// Either prop is written to, but there's no binding, which means we
		// create a derived that we can write to locally.
		// Or we are in legacy mode where we always create a derived to replicate that
		// Svelte 4 did not trigger updates when a primitive value was updated to the same value.
		var overridden = false;

		var d = ((flags & PROPS_IS_IMMUTABLE) !== 0 ? derived : derived_safe_equal)(() => {
			overridden = false;
			return getter();
		});

		if (DEV) {
			d.label = key;
		}

		// Capture the initial value if it's bindable
		if (bindable) get$1(d);

		var parent_effect = /** @type {Effect} */ (active_effect);

		return /** @type {() => V} */ (
			function (/** @type {any} */ value, /** @type {boolean} */ mutation) {
				if (arguments.length > 0) {
					const new_value = mutation ? get$1(d) : runes && bindable ? proxy(value) : value;

					set(d, new_value);
					overridden = true;

					if (fallback_value !== undefined) {
						fallback_value = new_value;
					}

					return value;
				}

				// special case — avoid recalculating the derived if we're in a
				// teardown function and the prop was overridden locally, or the
				// component was already destroyed (this latter part is necessary
				// because `bind:this` can read props after the component has
				// been destroyed. TODO simplify `bind:this`
				if ((is_destroying_effect && overridden) || (parent_effect.f & DESTROYED) !== 0) {
					return d.v;
				}

				return get$1(d);
			}
		);
	}

	const socket = new WebSocket('wss://api.vote.poker');

	socket.addEventListener('open', () => {
	    //Default AWS timeout is 10 mins so ping server with message every 5 mins to stay connected
	    setInterval(() => {
	        socket.send(JSON.stringify({
	            "action": "ping"
	        }));
	    }, 5 * 60 * 1000);
	});

	var roomStore = (function () {
	    const { subscribe, update } = writable({
	        id: '',
	        owner: '',
	        votes_revealed: false,
	        settings: {}
	    });

	    let room_id = "";
	    let saved_name = "";
	    let saved_observer = false;

	    socket.addEventListener('message', function (event) {
	        const message = JSON.parse(event.data);

	        {
	            console.log("Message received from server: " + message.action);
	            console.log(message.data);
	        }

	        switch (message.action) {
	            case 'roomcreated':
	                join(message.data.room_id, saved_name, saved_observer);
	                break;

	            case 'roomsettingschanged':
	                room_id = message.data.room_id;

	                update((room) => {
	                    return {
	                        id: room_id,
	                        owner: message.data.room_owner,
	                        votes_revealed: message.data.votes_revealed,
	                        settings: message.data.room_settings
	                    };
	                });

	                window.history.pushState(
	                    { room_id: room_id },
	                    '',
	                    '?' + room_id
	                );
	                break;

	            case 'votesreset':
	                update((room) => {
	                    return {
	                        id: room.id,
	                        owner: room.owner,
	                        votes_revealed: false,
	                        settings: room.settings
	                    };
	                });
	                break;
	        }
	    });

	    const sendMessageToServer = function (action, messageData) {
	        {
	            console.log("Sending message to server: " + action);
	            console.log(messageData);
	        }

	        socket.send(JSON.stringify({
	            "action": action,
	            "data": messageData
	        }));
	    };

	    const create = function (name, observer) {
	        saved_name = name;
	        saved_observer = observer;

	        sendMessageToServer('createroom', {
	            "settings": {
	                "test": "test"
	            }
	        });
	    };

	    const join = function (room_id, name, observer) {
	        sendMessageToServer('joinroom', {
	            "room_id": room_id,
	            "name": name,
	            "settings": {
	                "observer": observer
	            }
	        });
	    };

	    const changeSettings = function (new_settings) {
	        update((room) => {
	            return {
	                id: room.id,
	                owner: room.room_owner,
	                votes_revealed: room.votes_revealed,
	                settings: new_settings
	            };
	        });

	        sendMessageToServer('changeroomsettings', {
	            "room_id": room_id,
	            "settings": new_settings
	        });
	    };

	    const revealVotes = function () {
	        sendMessageToServer('revealvotes', {
	            "room_id": room_id
	        });
	    };

	    const resetVotes = function () {
	        sendMessageToServer('resetvotes', {
	            "room_id": room_id
	        });
	    };

	    const fetchRoomInfo = function (joining_room_id) {
	        sendMessageToServer('getroominfo', {
	            "room_id": joining_room_id
	        });
	    };

	    return {
	        subscribe,
	        create,
	        join,
	        changeSettings,
	        revealVotes,
	        resetVotes,
	        fetchRoomInfo
	    }
	})();

	var votersStore = (function () {
	    const { subscribe, update } = writable({
	        us: "",
	        my_vote: 0,
	        voters: []
	    });

	    socket.addEventListener('message', function (event) {
	        const message = JSON.parse(event.data);

	        {
	            console.log("Message received from server: " + message.action);
	            console.log(message.data);
	        }

	        switch (message.action) {
	            case 'votersupdated':
	                update((voter_info) => {
	                    return {
	                        us: message.data.us,
	                        my_vote: voter_info.my_vote,
	                        voters: message.data.voters
	                    };
	                });
	                break;

	            case 'votesreset':
	                update((voter_info) => {
	                    return {
	                        us: voter_info.us,
	                        my_vote: 0,
	                        voters: voter_info.voters.map((voter) => {
	                            let newv = {...voter};
	                            delete newv.vote;
	                            newv.vote_placed = false;

	                            return newv;
	                        })
	                    };
	                });
	                break;
	        }
	    });

	    const sendMessageToServer = function (action, messageData) {
	        {
	            console.log("Sending message to server: " + action);
	            console.log(messageData);
	        }

	        socket.send(JSON.stringify({
	            "action": action,
	            "data": messageData
	        }));
	    };

	    return {
	        subscribe,
	        placeVote: (value) => {
	            update((voter_info) => {
	                return {
	                    us: voter_info.us,
	                    my_vote: value,
	                    voters: voter_info.voters.map((v) => {
	                        let newv = {...v};

	                        if (v.voter_id === voter_info.us) {
	                            newv.vote_placed = (value !== "");
	                        }

	                        return newv;
	                    })
	                }
	            });

	            sendMessageToServer('placevote', value);
	        },
	        changeName: (newName) => {
	            update((voter_info) => {
	                return {
	                    us: voter_info.us,
	                    my_vote: voter_info.my_vote,
	                    voters: voter_info.voters.map((v) => {
	                        let newv = {...v};

	                        if (v.voter_id === voter_info.us) {
	                            newv.voter_name = newName;
	                        }

	                        return newv;
	                    })
	                }
	            });

	            sendMessageToServer('changename', newName);
	        }
	    }
	})();

	RoomLink[FILENAME] = 'src/RoomLink.svelte';

	var root$8 = add_locations(from_html(`<h2 title="Click to copy" class="svelte-143m6nc"> </h2>`), RoomLink[FILENAME], [[5, 0]]);

	function RoomLink($$anchor, $$props) {
		check_target(new.target);
		push($$props, false, RoomLink);

		const $roomstore = () => (
			validate_store(roomStore, 'roomstore'),
			store_get(roomStore, '$roomstore', $$stores)
		);

		const [$$stores, $$cleanup] = setup_stores();
		var $$exports = { ...legacy_api() };

		init();

		var h2 = root$8();
		var event_handler = user_derived(() => navigator.clipboard.writeText("https://vote.poker/?" + $roomstore().id));
		var text = child(h2);
		template_effect(() => set_text(text, `https://vote.poker/?${$roomstore().id ?? ''}`));

		event('click', h2, function (...$$args) {
			apply(() => get$1(event_handler), this, $$args, RoomLink, [5, 37], true);
		});

		append($$anchor, h2);

		var $$pop = pop($$exports);

		$$cleanup();

		return $$pop;
	}

	Button[FILENAME] = 'src/Button.svelte';

	var root$7 = add_locations(from_html(`<button class="svelte-1fe1l3"> </button>`), Button[FILENAME], [[5, 0]]);

	function Button($$anchor, $$props) {
		check_target(new.target);
		push($$props, false, Button);

		let value = prop($$props, 'value', 8, '');
		var $$exports = { ...legacy_api() };
		var button = root$7();
		var text = child(button);
		template_effect(() => set_text(text, value()));

		event('click', button, function ($$arg) {
			bubble_event.call(this, $$props, $$arg);
		});

		append($$anchor, button);

		return pop($$exports);
	}

	Voter[FILENAME] = 'src/Voter.svelte';

	var root_2$2 = add_locations(from_html(`<input type="text" size="10"/> <!> <span class="name us svelte-z2q2l9">(You)</span>`, 1), Voter[FILENAME], [[45, 12], [47, 12]]);
	var root_3 = add_locations(from_html(`<span class="name us svelte-z2q2l9"><span class="changename svelte-z2q2l9"> </span> (You)</span>`), Voter[FILENAME], [[49, 12, [[49, 34]]]]);
	var root_4 = add_locations(from_html(`<span class="name svelte-z2q2l9"> </span>`), Voter[FILENAME], [[52, 8]]);
	var root$6 = add_locations(from_html(`<div><span class="vote svelte-z2q2l9"> </span> <!></div>`), Voter[FILENAME], [[41, 0, [[42, 4]]]]);

	function Voter($$anchor, $$props) {
		check_target(new.target);
		push($$props, false, Voter);

		const $votersstore = () => (
			validate_store(votersStore, 'votersstore'),
			store_get(votersStore, '$votersstore', $$stores)
		);

		const $roomstore = () => (
			validate_store(roomStore, 'roomstore'),
			store_get(roomStore, '$roomstore', $$stores)
		);

		const [$$stores, $$cleanup] = setup_stores();
		let id = prop($$props, 'id', 8, null);
		let name = mutable_source("");
		let new_name = mutable_source("");
		let vote = mutable_source("");
		let hasVoted = mutable_source();
		let changingName = mutable_source(false);

		function changeName() {
			set(new_name, get$1(name));
			set(changingName, true);
		}

		function submitNameChange() {
			votersStore.changeName(get$1(new_name));
			set(changingName, false);
		}

		legacy_pre_effect(() => ($votersstore(), deep_read_state(id()), $roomstore()), () => {
			const thisVoter = $votersstore().voters.filter((v) => strict_equals(v.voter_id, id()))[0];

			if ($roomstore().votes_revealed && thisVoter.vote) {
				set(vote, thisVoter.vote);
			} else {
				set(vote, "");
			}

			if (thisVoter.voter_name) {
				set(name, thisVoter.voter_name);
			}

			set(hasVoted, thisVoter.vote_placed);
		});

		legacy_pre_effect_reset();

		var $$exports = { ...legacy_api() };

		init();

		var div = root$6();
		var span = child(div);
		var text = child(span);

		var node = sibling(span, 2);

		{
			var consequent_1 = ($$anchor) => {
				var fragment = comment();
				var node_1 = first_child(fragment);

				{
					var consequent = ($$anchor) => {
						var fragment_1 = root_2$2();
						var input = first_child(fragment_1);

						var node_2 = sibling(input, 2);

						add_svelte_meta(() => Button(node_2, { value: 'Change Name', $$events: { click: submitNameChange } }), 'component', Voter, 46, 12, { componentTag: 'Button' });
						bind_value(input, () => get$1(new_name), ($$value) => set(new_name, $$value));
						append($$anchor, fragment_1);
					};

					var alternate = ($$anchor) => {
						var span_1 = root_3();
						var span_2 = child(span_1);
						var text_1 = child(span_2);
						template_effect(() => set_text(text_1, get$1(name)));
						event('click', span_2, changeName);
						append($$anchor, span_1);
					};

					add_svelte_meta(
						() => if_block(node_1, ($$render) => {
							if (get$1(changingName)) $$render(consequent); else $$render(alternate, false);
						}),
						'if',
						Voter,
						44,
						8
					);
				}

				append($$anchor, fragment);
			};

			var alternate_1 = ($$anchor) => {
				var span_3 = root_4();
				var text_2 = child(span_3);
				template_effect(() => set_text(text_2, get$1(name)));
				append($$anchor, span_3);
			};

			add_svelte_meta(
				() => if_block(node, ($$render) => {
					if ((
						deep_read_state(id()),
						$votersstore(),
						untrack(() => strict_equals(id(), $votersstore().us))
					)) $$render(consequent_1); else $$render(alternate_1, false);
				}),
				'if',
				Voter,
				43,
				4
			);
		}

		template_effect(() => {
			set_class(
				div,
				1,
				(
					get$1(hasVoted),
					$roomstore(),
					untrack(() => get$1(hasVoted) && !$roomstore().votes_revealed ? 'voted' : '')
				),
				'svelte-z2q2l9'
			);

			set_text(text, strict_equals(get$1(vote), "0") ? '' : get$1(vote));
		});

		append($$anchor, div);

		var $$pop = pop($$exports);

		$$cleanup();

		return $$pop;
	}

	VotingOption[FILENAME] = 'src/VotingOption.svelte';

	var root$5 = add_locations(from_html(`<div class="voting-option svelte-10dxao1"><div> </div></div>`), VotingOption[FILENAME], [[19, 0, [[20, 4]]]]);

	function VotingOption($$anchor, $$props) {
		check_target(new.target);
		push($$props, false, VotingOption);

		const $votersstore = () => (
			validate_store(votersStore, 'votersstore'),
			store_get(votersStore, '$votersstore', $$stores)
		);

		const $roomstore = () => (
			validate_store(roomStore, 'roomstore'),
			store_get(roomStore, '$roomstore', $$stores)
		);

		const [$$stores, $$cleanup] = setup_stores();
		const selected = mutable_source();
		let value = prop($$props, 'value', 8, 0);

		function placeVote(value) {
			if (!$roomstore().votes_revealed) {
				if (get$1(selected)) {
					votersStore.placeVote("");
				} else {
					votersStore.placeVote(value);
				}
			}
		}

		legacy_pre_effect(() => ($votersstore(), deep_read_state(value())), () => {
			set(selected, strict_equals($votersstore().my_vote, value()));
		});

		legacy_pre_effect_reset();

		var $$exports = { ...legacy_api() };

		init();

		var div = root$5();
		var div_1 = child(div);
		var text = child(div_1);

		template_effect(() => {
			set_class(
				div_1,
				1,
				`card ${(
				get$1(selected),
				$roomstore(),
				untrack(() => (get$1(selected) ? 'selected' : '') + ' ' + (!$roomstore().votes_revealed ? 'selectable' : ''))
			) ?? ''}`,
				'svelte-10dxao1'
			);

			set_text(text, value());
		});

		event('click', div_1, () => placeVote(value()));
		append($$anchor, div);

		var $$pop = pop($$exports);

		$$cleanup();

		return $$pop;
	}

	VotingOptions[FILENAME] = 'src/VotingOptions.svelte';

	var root$4 = add_locations(from_html(`<section class="voting-options svelte-1xm68su"><!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!></section>`), VotingOptions[FILENAME], [[6, 0]]);

	function VotingOptions($$anchor, $$props) {
		check_target(new.target);
		push($$props, false, VotingOptions);

		var $$exports = { ...legacy_api() };
		var section = root$4();
		var node = child(section);

		add_svelte_meta(() => VotingOption(node, { value: '1' }), 'component', VotingOptions, 7, 4, { componentTag: 'VotingOption' });

		var node_1 = sibling(node, 2);

		add_svelte_meta(() => VotingOption(node_1, { value: '2' }), 'component', VotingOptions, 8, 4, { componentTag: 'VotingOption' });

		var node_2 = sibling(node_1, 2);

		add_svelte_meta(() => VotingOption(node_2, { value: '3' }), 'component', VotingOptions, 9, 4, { componentTag: 'VotingOption' });

		var node_3 = sibling(node_2, 2);

		add_svelte_meta(() => VotingOption(node_3, { value: '5' }), 'component', VotingOptions, 10, 4, { componentTag: 'VotingOption' });

		var node_4 = sibling(node_3, 2);

		add_svelte_meta(() => VotingOption(node_4, { value: '8' }), 'component', VotingOptions, 11, 4, { componentTag: 'VotingOption' });

		var node_5 = sibling(node_4, 2);

		add_svelte_meta(() => VotingOption(node_5, { value: '13' }), 'component', VotingOptions, 12, 4, { componentTag: 'VotingOption' });

		var node_6 = sibling(node_5, 2);

		add_svelte_meta(() => VotingOption(node_6, { value: '21' }), 'component', VotingOptions, 13, 4, { componentTag: 'VotingOption' });

		var node_7 = sibling(node_6, 2);

		add_svelte_meta(() => VotingOption(node_7, { value: '34' }), 'component', VotingOptions, 14, 4, { componentTag: 'VotingOption' });

		var node_8 = sibling(node_7, 2);

		add_svelte_meta(() => VotingOption(node_8, { value: '55' }), 'component', VotingOptions, 15, 4, { componentTag: 'VotingOption' });

		var node_9 = sibling(node_8, 2);

		add_svelte_meta(() => VotingOption(node_9, { value: '89' }), 'component', VotingOptions, 16, 4, { componentTag: 'VotingOption' });

		var node_10 = sibling(node_9, 2);

		add_svelte_meta(() => VotingOption(node_10, { value: '?' }), 'component', VotingOptions, 17, 4, { componentTag: 'VotingOption' });
		append($$anchor, section);

		return pop($$exports);
	}

	RoomControls[FILENAME] = 'src/RoomControls.svelte';

	function RoomControls($$anchor, $$props) {
		check_target(new.target);
		push($$props, false, RoomControls);

		const $roomstore = () => (
			validate_store(roomStore, 'roomstore'),
			store_get(roomStore, '$roomstore', $$stores)
		);

		const [$$stores, $$cleanup] = setup_stores();
		let disable_buttons = mutable_source(false);

		socket.addEventListener('message', function (event) {
			const message = JSON.parse(event.data);

			if (strict_equals(message.action, 'roomsettingschanged') && strict_equals(message.data.votes_revealed, true) || strict_equals(message.action, 'votesreset')) {
				set(disable_buttons, false);
			}
		});

		function resetVotes() {
			set(disable_buttons, true);
			roomStore.resetVotes();
		}

		function revealVotes() {
			set(disable_buttons, true);
			roomStore.revealVotes();
		}

		var $$exports = { ...legacy_api() };

		init();

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				add_svelte_meta(
					() => Button($$anchor, {
						value: 'Reset Votes',

						get disabled() {
							return get$1(disable_buttons);
						},

						set disabled($$value) {
							set(disable_buttons, $$value);
						},

						$$events: { click: resetVotes },
						$$legacy: true
					}),
					'component',
					RoomControls,
					28,
					4,
					{ componentTag: 'Button' }
				);
			};

			var alternate = ($$anchor) => {
				add_svelte_meta(
					() => Button($$anchor, {
						value: 'Reveal Votes',

						get disabled() {
							return get$1(disable_buttons);
						},

						set disabled($$value) {
							set(disable_buttons, $$value);
						},

						$$events: { click: revealVotes },
						$$legacy: true
					}),
					'component',
					RoomControls,
					30,
					4,
					{ componentTag: 'Button' }
				);
			};

			add_svelte_meta(
				() => if_block(node, ($$render) => {
					if ($roomstore().votes_revealed) $$render(consequent); else $$render(alternate, false);
				}),
				'if',
				RoomControls,
				27,
				0
			);
		}

		append($$anchor, fragment);

		var $$pop = pop($$exports);

		$$cleanup();

		return $$pop;
	}

	Room[FILENAME] = 'src/Room.svelte';

	var root$3 = add_locations(from_html(`<!> <!> <div id="observers" class="svelte-va3agg"><p><strong>Observers:</strong> </p></div> <div id="voters" class="svelte-va3agg"><!> <!></div> <!>`, 1), Room[FILENAME], [[22, 0, [[23, 4, [[23, 7]]]]], [26, 0]]);

	function Room($$anchor, $$props) {
		check_target(new.target);
		push($$props, false, Room);

		const $votersStore = () => (
			validate_store(votersStore, 'votersStore'),
			store_get(votersStore, '$votersStore', $$stores)
		);

		const $roomStore = () => (
			validate_store(roomStore, 'roomStore'),
			store_get(roomStore, '$roomStore', $$stores)
		);

		const [$$stores, $$cleanup] = setup_stores();
		const observers = mutable_source();

		legacy_pre_effect(() => ($votersStore()), () => {
			set(observers, [
				...$votersStore().voters.filter((v) => v.settings.observer && strict_equals(v.voter_id, $votersStore().us)),
				...$votersStore().voters.filter((v) => v.settings.observer && strict_equals(v.voter_id, $votersStore().us, false))
			]);
		});

		legacy_pre_effect_reset();

		var $$exports = { ...legacy_api() };

		init();

		var fragment = root$3();
		var node = first_child(fragment);

		add_svelte_meta(() => RoomLink(node, {}), 'component', Room, 16, 0, { componentTag: 'RoomLink' });

		var node_1 = sibling(node, 2);

		{
			var consequent = ($$anchor) => {
				add_svelte_meta(() => RoomControls($$anchor, {}), 'component', Room, 19, 4, { componentTag: 'RoomControls' });
			};

			add_svelte_meta(
				() => if_block(node_1, ($$render) => {
					if ((
						$votersStore(),
						$roomStore(),
						untrack(() => strict_equals($votersStore().us, $roomStore().owner))
					)) $$render(consequent);
				}),
				'if',
				Room,
				18,
				0
			);
		}

		var div = sibling(node_1, 2);
		var p = child(div);
		var text = sibling(child(p));

		var div_1 = sibling(div, 2);
		var node_2 = child(div_1);

		add_svelte_meta(
			() => each(
				node_2,
				1,
				() => (
					$votersStore(),
					untrack(() => $votersStore().voters.filter((v) => !v.settings.observer && strict_equals(v.voter_id, $votersStore().us)))
				),
				index,
				($$anchor, voter) => {
					add_svelte_meta(
						() => Voter($$anchor, {
							get id() {
								return (get$1(voter), untrack(() => get$1(voter).voter_id));
							}
						}),
						'component',
						Room,
						28,
						4,
						{ componentTag: 'Voter' }
					);
				}
			),
			'each',
			Room,
			27,
			0
		);

		var node_3 = sibling(node_2, 2);

		add_svelte_meta(
			() => each(
				node_3,
				1,
				() => (
					$votersStore(),
					untrack(() => $votersStore().voters.filter((v) => !v.settings.observer && strict_equals(v.voter_id, $votersStore().us, false)))
				),
				index,
				($$anchor, voter) => {
					add_svelte_meta(
						() => Voter($$anchor, {
							get id() {
								return (get$1(voter), untrack(() => get$1(voter).voter_id));
							}
						}),
						'component',
						Room,
						31,
						4,
						{ componentTag: 'Voter' }
					);
				}
			),
			'each',
			Room,
			30,
			0
		);

		var node_4 = sibling(div_1, 2);

		{
			var consequent_1 = ($$anchor) => {
				add_svelte_meta(() => VotingOptions($$anchor, {}), 'component', Room, 37, 0, { componentTag: 'VotingOptions' });
			};

			add_svelte_meta(
				() => if_block(node_4, ($$render) => {
					if ((
						$votersStore(),
						untrack(() => $votersStore().voters.filter((v) => strict_equals(v.voter_id, $votersStore().us)).length > 0 && !$votersStore().voters.filter((v) => strict_equals(v.voter_id, $votersStore().us))[0].settings.observer)
					)) $$render(consequent_1);
				}),
				'if',
				Room,
				35,
				0
			);
		}

		template_effect(($0) => set_text(text, ` ${$0 ?? ''}`), [
			() => (
				get$1(observers),
				untrack(() => get$1(observers).map((v) => v.voter_name.trim()).join(", "))
			)
		]);

		append($$anchor, fragment);

		var $$pop = pop($$exports);

		$$cleanup();

		return $$pop;
	}

	Loading[FILENAME] = 'src/Loading.svelte';

	var root$2 = add_locations(from_html(`<img src="loading.svg" alt="Loading..."/>`), Loading[FILENAME], [[1, 0]]);

	function Loading($$anchor, $$props) {
		check_target(new.target);
		push($$props, false, Loading);

		var $$exports = { ...legacy_api() };
		var img = root$2();

		append($$anchor, img);

		return pop($$exports);
	}

	CreateRoom[FILENAME] = 'src/CreateRoom.svelte';

	var root_2$1 = add_locations(from_html(`<input type="text" placeholder="Enter Your Name" class="svelte-1d0f4bc"/><br/> <label class="svelte-1d0f4bc"><input type="checkbox" name="observer" class="svelte-1d0f4bc"/> Observer</label> <div class="buttons svelte-1d0f4bc"><!></div>`, 1), CreateRoom[FILENAME], [[30, 4], [30, 94], [32, 4, [[33, 8]]], [36, 4]]);

	function CreateRoom($$anchor, $$props) {
		check_target(new.target);
		push($$props, false, CreateRoom);

		let observer = mutable_source(false);
		let loading = mutable_source(false);
		let name = mutable_source('');

		function createRoom() {
			set(loading, true);
			roomStore.create(get$1(name), get$1(observer));
		}

		function handleKeyUp(event) {
			const submitKeys = ['Enter', 'NumpadEnter'];

			if (submitKeys.includes(event.code)) {
				createRoom();
			}
		}

		var $$exports = { ...legacy_api() };

		init();

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				add_svelte_meta(() => Loading($$anchor, {}), 'component', CreateRoom, 28, 4, { componentTag: 'Loading' });
			};

			var alternate = ($$anchor) => {
				var fragment_2 = root_2$1();
				var input = first_child(fragment_2);

				var label = sibling(input, 3);
				var input_1 = child(label);
				input_1.value = input_1.__value = 'true';

				var div = sibling(label, 2);
				var node_1 = child(div);

				add_svelte_meta(() => Button(node_1, { value: 'Create New Room', $$events: { click: createRoom } }), 'component', CreateRoom, 37, 8, { componentTag: 'Button' });
				bind_value(input, () => get$1(name), ($$value) => set(name, $$value));
				event('keyup', input, handleKeyUp);
				bind_checked(input_1, () => get$1(observer), ($$value) => set(observer, $$value));
				append($$anchor, fragment_2);
			};

			add_svelte_meta(
				() => if_block(node, ($$render) => {
					if (get$1(loading)) $$render(consequent); else $$render(alternate, false);
				}),
				'if',
				CreateRoom,
				27,
				0
			);
		}

		append($$anchor, fragment);

		return pop($$exports);
	}

	JoinRoom[FILENAME] = 'src/JoinRoom.svelte';

	var root_2 = add_locations(from_html(`<input type="text" placeholder="Enter Your Name" class="svelte-hzyik"/><br/> <label class="svelte-hzyik"><input type="checkbox" name="observer" class="svelte-hzyik"/> Observer</label> <div class="buttons svelte-hzyik"><!></div>`, 1), JoinRoom[FILENAME], [[31, 4], [31, 94], [33, 4, [[34, 8]]], [37, 4]]);

	function JoinRoom($$anchor, $$props) {
		check_target(new.target);
		push($$props, false, JoinRoom);

		let room_id = prop($$props, 'room_id', 8, "");
		let loading = mutable_source(false);
		let name = mutable_source('');
		let observer = mutable_source(false);

		function joinRoom() {
			set(loading, true);
			roomStore.join(room_id(), get$1(name), get$1(observer));
		}

		function handleKeyUp(event) {
			const submitKeys = ['Enter', 'NumpadEnter'];

			if (submitKeys.includes(event.code)) {
				joinRoom();
			}
		}

		var $$exports = { ...legacy_api() };

		init();

		var fragment = comment();
		var node = first_child(fragment);

		{
			var consequent = ($$anchor) => {
				add_svelte_meta(() => Loading($$anchor, {}), 'component', JoinRoom, 29, 4, { componentTag: 'Loading' });
			};

			var alternate = ($$anchor) => {
				var fragment_2 = root_2();
				var input = first_child(fragment_2);

				var label = sibling(input, 3);
				var input_1 = child(label);
				input_1.value = input_1.__value = 'true';

				var div = sibling(label, 2);
				var node_1 = child(div);

				add_svelte_meta(() => Button(node_1, { value: 'Join Room', $$events: { click: joinRoom } }), 'component', JoinRoom, 38, 8, { componentTag: 'Button' });
				bind_value(input, () => get$1(name), ($$value) => set(name, $$value));
				event('keyup', input, handleKeyUp);
				bind_checked(input_1, () => get$1(observer), ($$value) => set(observer, $$value));
				append($$anchor, fragment_2);
			};

			add_svelte_meta(
				() => if_block(node, ($$render) => {
					if (get$1(loading)) $$render(consequent); else $$render(alternate, false);
				}),
				'if',
				JoinRoom,
				28,
				0
			);
		}

		append($$anchor, fragment);

		return pop($$exports);
	}

	RoomDoesntExist[FILENAME] = 'src/RoomDoesntExist.svelte';

	var root$1 = add_locations(from_html(`<div class="svelte-1650spa"><p class="svelte-1650spa">The room you tried to join doesn't exist</p></div>`), RoomDoesntExist[FILENAME], [[1, 0, [[2, 4]]]]);

	function RoomDoesntExist($$anchor, $$props) {
		check_target(new.target);
		push($$props, false, RoomDoesntExist);

		var $$exports = { ...legacy_api() };
		var div = root$1();

		append($$anchor, div);

		return pop($$exports);
	}

	App[FILENAME] = 'src/App.svelte';

	var root_6 = add_locations(from_html(`<!> <!>`, 1), App[FILENAME], []);
	var root = add_locations(from_html(`<main class="svelte-1n46o8q"><h1 class="svelte-1n46o8q">VOTE.POKER</h1> <!></main>`), App[FILENAME], [[39, 0, [[40, 4]]]]);

	function App($$anchor, $$props) {
		check_target(new.target);
		push($$props, false, App);

		const $roomStore = () => (
			validate_store(roomStore, 'roomStore'),
			store_get(roomStore, '$roomStore', $$stores)
		);

		const [$$stores, $$cleanup] = setup_stores();
		const in_room = mutable_source();
		let connected = mutable_source(false);
		let joiningroom = mutable_source(false);
		let joiningroom_id = mutable_source("");
		let room_doesnt_exist_message = mutable_source(false);

		if (strict_equals(window.location.search, "", false)) {
			set(joiningroom_id, window.location.search.substring(1));

			if (strict_equals(get$1(joiningroom_id), "roomdoesntexist")) {
				set(room_doesnt_exist_message, true);
			} else {
				set(joiningroom, true);
			}
		}

		socket.addEventListener('open', () => set(connected, true));

		socket.addEventListener('message', function (event) {
			const message = JSON.parse(event.data);

			if (strict_equals(message.action, "roomdoesntexist")) {
				window.location.href = '/?roomdoesntexist';
			}
		});

		legacy_pre_effect(() => ($roomStore()), () => {
			set(in_room, !!($roomStore().id && strict_equals($roomStore().id, "", false)));
		});

		legacy_pre_effect_reset();

		var $$exports = { ...legacy_api() };

		init();

		var main = root();
		var node = sibling(child(main), 2);

		{
			var consequent = ($$anchor) => {
				add_svelte_meta(() => Loading($$anchor, {}), 'component', App, 42, 4, { componentTag: 'Loading' });
			};

			var alternate_2 = ($$anchor) => {
				var fragment_1 = comment();
				var node_1 = first_child(fragment_1);

				{
					var consequent_1 = ($$anchor) => {
						add_svelte_meta(() => Room($$anchor, {}), 'component', App, 44, 4, { componentTag: 'Room' });
					};

					var alternate_1 = ($$anchor) => {
						var fragment_3 = comment();
						var node_2 = first_child(fragment_3);

						{
							var consequent_2 = ($$anchor) => {
								add_svelte_meta(
									() => JoinRoom($$anchor, {
										get room_id() {
											return get$1(joiningroom_id);
										}
									}),
									'component',
									App,
									46,
									4,
									{ componentTag: 'JoinRoom' }
								);
							};

							var alternate = ($$anchor) => {
								var fragment_5 = root_6();
								var node_3 = first_child(fragment_5);

								{
									var consequent_3 = ($$anchor) => {
										add_svelte_meta(() => RoomDoesntExist($$anchor, {}), 'component', App, 49, 8, { componentTag: 'RoomDoesntExist' });
									};

									add_svelte_meta(
										() => if_block(node_3, ($$render) => {
											if (get$1(room_doesnt_exist_message)) $$render(consequent_3);
										}),
										'if',
										App,
										48,
										4
									);
								}

								var node_4 = sibling(node_3, 2);

								add_svelte_meta(() => CreateRoom(node_4, {}), 'component', App, 51, 4, { componentTag: 'CreateRoom' });
								append($$anchor, fragment_5);
							};

							add_svelte_meta(
								() => if_block(
									node_2,
									($$render) => {
										if (get$1(joiningroom)) $$render(consequent_2); else $$render(alternate, false);
									},
									true
								),
								'if',
								App,
								45,
								0
							);
						}

						append($$anchor, fragment_3);
					};

					add_svelte_meta(
						() => if_block(
							node_1,
							($$render) => {
								if (get$1(in_room)) $$render(consequent_1); else $$render(alternate_1, false);
							},
							true
						),
						'if',
						App,
						43,
						0
					);
				}

				append($$anchor, fragment_1);
			};

			add_svelte_meta(
				() => if_block(node, ($$render) => {
					if (!get$1(connected)) $$render(consequent); else $$render(alternate_2, false);
				}),
				'if',
				App,
				41,
				0
			);
		}
		append($$anchor, main);

		var $$pop = pop($$exports);

		$$cleanup();

		return $$pop;
	}

	/* This file is generated by scripts/process-messages/index.js. Do not edit! */

	/**
	 * `%name%(...)` is not available on the server
	 * @param {string} name
	 * @returns {never}
	 */
	function lifecycle_function_unavailable(name) {
		const error = new Error(`lifecycle_function_unavailable\n\`${name}(...)\` is not available on the server\nhttps://svelte.dev/e/lifecycle_function_unavailable`);

		error.name = 'Svelte error';

		throw error;
	}

	/** @import { SSRContext } from '#server' */

	function mount() {
		lifecycle_function_unavailable('mount');
	}

	mount();

})();
//# sourceMappingURL=bundle.js.map
